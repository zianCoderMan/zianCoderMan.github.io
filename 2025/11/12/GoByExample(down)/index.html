<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Go语言基础学习（下） | zianCoderMan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="本文根据《Go by Example》进行学习，参考资料出自https:&#x2F;&#x2F;gobyexample-cn.github.io&#x2F; 上篇包括Go语言基础部分，从Hello World到错误处理；中篇包括协程与通道；下篇包括各种工具类的使用。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言基础学习（下）">
<meta property="og:url" content="https://ziancoderman.github.io/2025/11/12/GoByExample(down)/index.html">
<meta property="og:site_name" content="zianCoderMan">
<meta property="og:description" content="本文根据《Go by Example》进行学习，参考资料出自https:&#x2F;&#x2F;gobyexample-cn.github.io&#x2F; 上篇包括Go语言基础部分，从Hello World到错误处理；中篇包括协程与通道；下篇包括各种工具类的使用。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-12T01:35:00.000Z">
<meta property="article:modified_time" content="2025-11-13T05:24:23.163Z">
<meta property="article:author" content="zianCoderMan">
<meta property="article:tag" content="Go学习">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="zianCoderMan" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zianCoderMan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ziancoderman.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-GoByExample(down)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/12/GoByExample(down)/" class="article-date">
  <time class="dt-published" datetime="2025-11-12T01:35:00.000Z" itemprop="datePublished">2025-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Go语言基础学习（下）
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文根据《Go by Example》进行学习，参考资料出自<a target="_blank" rel="noopener" href="https://gobyexample-cn.github.io/">https://gobyexample-cn.github.io/</a></p>
<p>上篇包括Go语言基础部分，从Hello World到错误处理；中篇包括协程与通道；下篇包括各种工具类的使用。</p>
<span id="more"></span>

<h2 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义字符串切片，包含 3 个无序元素</span></span><br><span class="line">    strs := []<span class="type">string</span>&#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">    <span class="comment">// 对字符串切片进行升序排序（原地排序，直接修改原切片）</span></span><br><span class="line">    sort.Strings(strs)</span><br><span class="line">    <span class="comment">// 输出排序后的结果：[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Strings:&quot;</span>, strs)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义整数切片，包含 3 个无序元素</span></span><br><span class="line">    ints := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">    <span class="comment">// 对整数切片进行升序排序（同样是原地排序）</span></span><br><span class="line">    sort.Ints(ints)</span><br><span class="line">    <span class="comment">// 输出排序后的结果：[2, 4, 7]</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Ints:   &quot;</span>, ints)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验整数切片是否已升序排序（返回 bool 值）</span></span><br><span class="line">    s := sort.IntsAreSorted(ints)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted: &quot;</span>, s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键现象：原地排序</strong></p>
<p>注意一个核心特点：<code>sort.Strings</code> 和 <code>sort.Ints</code> 都是 <strong>原地排序</strong>—— 排序时直接修改原切片的元素顺序，不会创建新切片。比如 <code>strs</code> 原本是 <code>[&quot;c&quot;, &quot;a&quot;, &quot;b&quot;]</code>，排序后原切片变成 <code>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</code>，无需额外接收返回值（函数返回值为 <code>void</code>）。</p>
<p><strong>核心 API 详解（<code>sort</code> 包基础函数）</strong></p>
<p><code>sort</code> 包针对 Go 内置的基本类型（<code>string</code>、<code>int</code>、<code>float64</code>）提供了「开箱即用」的排序函数，无需手动实现排序逻辑，下面是最常用的 3 组 API：</p>
<table>
<thead>
<tr>
<th>API 函数</th>
<th>作用</th>
<th>适用类型</th>
<th>排序规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>sort.Strings(s []string)</code></td>
<td>对字符串切片排序</td>
<td><code>[]string</code></td>
<td>字典序（升序）</td>
</tr>
<tr>
<td><code>sort.Ints(x []int)</code></td>
<td>对整数切片排序</td>
<td><code>[]int</code></td>
<td>数值升序</td>
</tr>
<tr>
<td><code>sort.Float64s(x []float64)</code></td>
<td>对浮点数切片排序</td>
<td><code>[]float64</code></td>
<td>数值升序</td>
</tr>
<tr>
<td><code>sort.StringsAreSorted(s []string) bool</code></td>
<td>校验字符串切片是否已升序排序</td>
<td><code>[]string</code></td>
<td>字典序校验</td>
</tr>
<tr>
<td><code>sort.IntsAreSorted(x []int) bool</code></td>
<td>校验整数切片是否已升序排序</td>
<td><code>[]int</code></td>
<td>数值升序校验</td>
</tr>
<tr>
<td><code>sort.Float64sAreSorted(x []float64) bool</code></td>
<td>校验浮点数切片是否已升序排序</td>
<td><code>[]float64</code></td>
<td>数值升序校验</td>
</tr>
</tbody></table>
<p><strong>补充说明：</strong></p>
<ol>
<li>字符串排序规则：按「Unicode 码点（Code Point）」升序排列，也就是我们常说的「字典序」，但要注意：<ul>
<li>大写字母的 Unicode 码点小于小写字母（如 ‘A’&#x3D;65，’a’&#x3D;97），所以 <code>[&quot;B&quot;, &quot;a&quot;]</code> 排序后是 <code>[&quot;B&quot;, &quot;a&quot;]</code>；</li>
<li>中文按 Unicode 码点排序（如 “张三” &lt; “李四”，因为 ‘ 张 ‘ 的 Unicode 码点小于 ‘ 李 ‘）。</li>
</ul>
</li>
<li><strong>校验函数的用途</strong>：避免重复排序（比如先判断切片是否已排序，若未排序再执行排序操作，提升性能）。</li>
</ol>
<p><strong>扩展用法：突破基础类型，实现自定义排序</strong></p>
<p>上面的 API 仅支持内置基本类型的升序排序，若需要：</p>
<ul>
<li>对 <strong>自定义结构体切片</strong> 排序（如 <code>[]Person</code> 按年龄 &#x2F; 姓名排序）；</li>
<li>对基本类型进行 <strong>降序排序</strong>（如 <code>[]int</code> 从大到小排序）；</li>
<li>按 <strong>自定义规则</strong> 排序（如字符串按长度排序）；</li>
</ul>
<p>就需要用到 <code>sort</code> 包的核心接口 <code>sort.Interface</code>，它定义了排序的「三要素」：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    Len() <span class="type">int</span>           <span class="comment">// 返回切片长度</span></span><br><span class="line">    Less(i, j <span class="type">int</span>) <span class="type">bool</span> <span class="comment">// 定义排序规则：i 元素是否应该排在 j 元素前面（true=是）</span></span><br><span class="line">    Swap(i, j <span class="type">int</span>)      <span class="comment">// 交换 i 和 j 元素的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要自定义类型（通常是切片）实现了这三个方法，就能用 <code>sort.Sort()</code> 函数排序。下面举 2 个高频场景示例：</p>
<p><strong>示例 1：整数切片降序排序</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ints := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">    <span class="comment">// 方式 1：用 sort.Slice （Go 1.8+ 推荐，更简洁）</span></span><br><span class="line">    sort.Slice(ints, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ints[i] &gt; ints[j] <span class="comment">// 降序规则：i 元素 &gt; j 元素时，i 排在前面</span></span><br><span class="line">    &#125;)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Ints 降序:&quot;</span>, ints) <span class="comment">// 输出：[7,4,2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方式 2：实现 sort.Interface 接口（传统方式）</span></span><br><span class="line">    <span class="keyword">type</span> IntSlice []<span class="type">int</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s IntSlice)</span></span> Len() <span class="type">int</span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(s) &#125;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s IntSlice)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> s[i] &gt; s[j] &#125; <span class="comment">// 降序规则</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="params">(s IntSlice)</span></span> Swap(i, j <span class="type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;</span><br><span class="line"></span><br><span class="line">    ints2 := []<span class="type">int</span>&#123;<span class="number">7</span>, <span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line">    sort.Sort(IntSlice(ints2))</span><br><span class="line">    fmt.Println(<span class="string">&quot;Ints 降序（接口方式）:&quot;</span>, ints2) <span class="comment">// 输出：[7,4,2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：自定义结构体切片排序（按年龄升序，年龄相同按姓名字典序）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义自定义结构体</span></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="comment">// 姓名</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="comment">// 年龄</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    people := []Person&#123;</span><br><span class="line">        &#123;<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;Charlie&quot;</span>, <span class="number">20</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用 sort.Slice 实现自定义排序（最简洁）</span></span><br><span class="line">    sort.Slice(people, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 排序规则：先按年龄升序，年龄相同按姓名字典序升序</span></span><br><span class="line">        <span class="keyword">if</span> people[i].Age == people[j].Age &#123;</span><br><span class="line">            <span class="keyword">return</span> people[i].Name &lt; people[j].Name <span class="comment">// 姓名字典序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> people[i].Age &lt; people[j].Age <span class="comment">// 年龄升序</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;按年龄+姓名排序:&quot;</span>, people)</span><br><span class="line">    <span class="comment">// 输出：[&#123;Alice 20&#125; &#123;Charlie 20&#125; &#123;Bob 25&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心注意点</strong></p>
<p><strong>1.原地排序的副作用</strong>：排序会直接修改原切片，若需要保留原切片，需先创建副本再排序：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strs := []<span class="type">string</span>&#123;<span class="string">&quot;c&quot;</span>, <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;</span><br><span class="line">strsCopy := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(strs))</span><br><span class="line"><span class="built_in">copy</span>(strsCopy, strs) <span class="comment">// 复制原切片</span></span><br><span class="line">sort.Strings(strsCopy) <span class="comment">// 对副本排序，原切片不变</span></span><br></pre></td></tr></table></figure>

<p><strong>2.<code>sort.Slice</code> 是首选</strong>：Go 1.8 引入的 <code>sort.Slice</code> 无需手动实现 <code>sort.Interface</code>，直接通过匿名函数定义 <code>Less</code> 规则，代码更简洁，优先使用；</p>
<p><strong>3.空切片 &#x2F; 长度为 1 的切片</strong>：排序函数会直接返回，无报错（<code>sort.StringsAreSorted</code> 会返回 <code>true</code>）；</p>
<p><strong>4.浮点数排序的特殊情况</strong>：<code>NaN</code>（非数字）会被排在最后（因为 <code>sort.Float64s</code> 中 <code>NaN &lt; 任何数</code> 都返回 <code>false</code>）。</p>
<h2 id="2-使用函数自定义排序"><a href="#2-使用函数自定义排序" class="headerlink" title="2.使用函数自定义排序"></a>2.使用函数自定义排序</h2><p>（同1扩展用法）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> byLength []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">    s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fruits := []<span class="type">string</span>&#123;<span class="string">&quot;peach&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>&#125;</span><br><span class="line">    sort.Sort(byLength(fruits))</span><br><span class="line">    fmt.Println(fruits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-panic"><a href="#3-panic" class="headerlink" title="3.panic"></a>3.panic</h2><p> <code>panic</code> 被调用时，程序会立即停止执行当前流程，进入「恐慌（Panic）模式」，并逐步向上（调用栈）传播，最终打印错误信息和调用栈日志后退出。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 panic：程序立即进入恐慌模式，停止执行后续代码</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下代码完全不会执行（被 panic 中断）</span></span><br><span class="line">    _, err := os.Create(<span class="string">&quot;/tmp/file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="comment">// 这个 panic 永远不会触发</span></span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>panic</code> 的核心特性</strong></p>
<p><strong>1. 触发后立即终止当前流程，后续代码不可达</strong></p>
<p><code>panic</code> 是「终止性」的 —— 一旦触发，当前函数的后续代码会直接跳过，程序不会继续执行。比如上面的代码，<code>panic</code> 之后的 <code>os.Create</code> 完全没机会运行。</p>
<p><strong>2. 支持传入任意类型的参数（不止字符串）</strong></p>
<p><code>panic</code> 的函数签名是 <code>func panic(v interface&#123;&#125;)</code>，可以传入任何类型的值作为错误信息，常见的有：</p>
<ul>
<li>字符串（直接描述错误）；</li>
<li><code>error</code> 类型（标准错误类型，包含详细错误信息）；</li>
<li>其他类型（如整数、结构体，但不推荐，可读性差）。</li>
</ul>
<p>示例：传入 <code>error</code> 类型（代码中被跳过的那个 <code>panic(err)</code> 就是这种场景）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, err := os.Create(<span class="string">&quot;/tmp/file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err) <span class="comment">// 传入 error 类型，会打印 err.Error() 的内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 会触发「延迟函数（<code>defer</code>）」执行（关键特性）</strong></p>
<p><code>panic</code> 触发后，虽然当前流程终止，但<strong>当前函数中已注册的 <code>defer</code> 函数会被优先执行</strong>（按「后进先出」顺序），执行完 <code>defer</code> 后，程序才会继续向上传播 panic 并退出。</p>
<p>示例：<code>defer</code> 在 panic 后的执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册 defer 函数：会在 panic 后、程序退出前执行</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 1: 清理资源 1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 2: 清理资源 2&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>) <span class="comment">// 触发 panic</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下 defer 不会被注册（因为 panic 中断了流程）</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 3: 不会执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">defer 2: 清理资源 2</span><br><span class="line">defer 1: 清理资源 1</span><br><span class="line">panic: a problem</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.main()</span><br><span class="line">        /path/to/your/code/main.go:9 +0x95</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure>

<p><strong>结论</strong>：<code>defer</code> 是 panic 场景下「资源清理」的唯一机会（如关闭文件、释放锁、断开连接）。</p>
<p><strong>4. 可以被 <code>recover</code> 捕获（避免程序退出）</strong></p>
<p><code>panic</code> 不是绝对的 “程序必死”—— 如果在 <code>defer</code> 函数中调用 <code>recover()</code>，可以捕获 panic，让程序恢复正常执行（后续会详细讲 <code>recover</code>，这里先知道这个特性）。</p>
<p>示例：用 <code>recover</code> 捕获 panic：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// recover() 必须在 defer 函数中调用，才能捕获 panic</span></span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;捕获到 panic：%v\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>) <span class="comment">// 触发 panic，但会被 recover 捕获</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;程序继续执行&quot;</span>) <span class="comment">// 这行依然不会执行（panic 会终止当前流程，直到 defer 执行）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">捕获到 panic：a problem</span><br></pre></td></tr></table></figure>

<p>程序不会退出，而是正常结束（退出状态码 0）。</p>
<p><strong><code>panic</code> 的使用场景</strong></p>
<p><strong>1.程序启动时的致命错误</strong>：比如配置文件加载失败、数据库连接初始化失败（程序无法正常运行，必须终止）；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 加载配置文件，失败则 panic（程序无法启动）</span></span><br><span class="line">    config, err := loadConfig(<span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">&quot;配置加载失败：%v&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.逻辑断言失败</strong>：比如代码执行到了 “理论上不可能到达” 的分支（说明程序逻辑有严重 bug）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 除零错误，属于逻辑断言失败（调用者应保证 b 不为 0）</span></span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;除数不能为 0&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3.不可恢复的资源错误</strong>：比如文件打开后无法关闭（但这种场景更推荐用 <code>defer</code> + 错误日志，而非 panic）。</p>
<p><strong>绝对不推荐使用 <code>panic</code> 的场景：</strong></p>
<ol>
<li><strong>普通业务错误</strong>：比如用户输入非法、网络请求超时、数据库查询无结果（这些错误是可预期的，应返回 <code>error</code> 让调用者处理）；</li>
<li><strong>库函数中</strong>：编写第三方库时，不要轻易触发 <code>panic</code>（会导致调用者的程序崩溃，违背 “库的稳定性” 原则），应返回 <code>error</code> 类型。</li>
</ol>
<p><strong><code>panic</code> 与 <code>error</code> 的核心区别</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th><code>panic</code>（异常）</th>
<th><code>error</code>（错误）</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>不可恢复的严重错误，触发程序中断</td>
<td>可预期的普通错误，仅传递错误信息</td>
</tr>
<tr>
<td>处理方式</td>
<td>用 <code>recover</code> 捕获（可选），否则程序退出</td>
<td>调用者显式判断、处理（如重试、返回友好提示）</td>
</tr>
<tr>
<td>适用场景</td>
<td>程序启动失败、逻辑断言失败等致命错误</td>
<td>用户输入错误、网络超时、文件不存在等普通错误</td>
</tr>
<tr>
<td>代码影响</td>
<td>终止当前流程，执行 <code>defer</code> 后退出（或恢复）</td>
<td>不影响程序执行流程，仅返回错误信息</td>
</tr>
<tr>
<td>最佳实践</td>
<td>尽量少用，仅用于致命错误</td>
<td>优先使用，显式处理所有可预期错误</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通错误：文件不存在，返回 error，让调用者处理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(path <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> _, err := os.Stat(path); os.IsNotExist(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;文件不存在：%w&quot;</span>, err) <span class="comment">// 返回 error，不 panic</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> os.ReadFile(path)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 严重错误：配置文件不存在，程序无法运行，panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">loadConfig</span><span class="params">(path <span class="type">string</span>)</span></span> (Config, <span class="type">error</span>) &#123;</span><br><span class="line">    data, err := readFile(path)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Config&#123;&#125;, fmt.Errorf(<span class="string">&quot;配置文件读取失败：%w&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析配置...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    config, err := loadConfig(<span class="string">&quot;config.yaml&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err) <span class="comment">// 配置加载失败，程序无法启动，panic</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-defer"><a href="#4-defer" class="headerlink" title="4.defer"></a>4.defer</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    f := createFile(<span class="string">&quot;/tmp/defer.txt&quot;</span>)</span><br><span class="line">    <span class="comment">// 注册 defer 函数：将 closeFile(f) 延迟到当前函数（main）退出前执行</span></span><br><span class="line">    <span class="keyword">defer</span> closeFile(f)</span><br><span class="line">    writeFile(f)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main 函数执行完毕，触发 defer 函数执行：调用 closeFile(f) 关闭文件（输出：closing）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createFile</span><span class="params">(p <span class="type">string</span>)</span></span> *os.File &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;creating&quot;</span>)</span><br><span class="line">    f, err := os.Create(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;writing&quot;</span>)</span><br><span class="line">    fmt.Fprintln(f, <span class="string">&quot;data&quot;</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closeFile</span><span class="params">(f *os.File)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;closing&quot;</span>)</span><br><span class="line">    err := f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Fprintf(os.Stderr, <span class="string">&quot;error: %v\n&quot;</span>, err)</span><br><span class="line">       os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>defer</code> 的核心特性</strong></p>
<p><strong>1. 执行时机：当前函数（或协程）退出前</strong></p>
<p><code>defer</code> 函数的执行时机是「包裹它的函数（如 <code>main</code>）执行完毕后、退出前」，而非代码执行到 <code>defer</code> 行时。常见触发函数退出的场景：</p>
<ul>
<li>函数正常执行完所有代码；</li>
<li>函数中触发 <code>panic</code>；</li>
<li>函数执行 <code>return</code> 语句。</li>
</ul>
<p><strong>2. 执行顺序：后进先出（LIFO）—— 栈式执行</strong></p>
<p>若同一函数中注册多个 <code>defer</code> 函数，执行顺序是「最后注册的先执行」，类似栈的「后进先出」。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 1&quot;</span>) <span class="comment">// 第一个注册</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 2&quot;</span>) <span class="comment">// 第二个注册</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 3&quot;</span>) <span class="comment">// 第三个注册</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;main 执行中&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main 执行中</span><br><span class="line">defer 3 // 最后注册，最先执行</span><br><span class="line">defer 2</span><br><span class="line">defer 1 // 最先注册，最后执行</span><br></pre></td></tr></table></figure>

<p><strong>3. 变量捕获：注册时拷贝变量值（非引用）</strong></p>
<p><code>defer</code> 函数注册时，会<strong>立即拷贝它所依赖的变量值</strong>，后续变量值的修改不会影响 <code>defer</code> 函数的执行结果。</p>
<p>示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    <span class="comment">// 注册时拷贝 x 的当前值（10）</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 捕获的 x：&quot;</span>, x) </span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span> <span class="comment">// 后续修改 x 的值，不影响 defer 的输出</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main 中的 x：&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main 中的 x： 20</span><br><span class="line">defer 捕获的 x： 10 // 捕获的是注册时的拷贝值</span><br></pre></td></tr></table></figure>

<p><strong>例外</strong>：若 <code>defer</code> 函数依赖的是「变量的指针」，则会受后续修改影响（因为拷贝的是指针地址，指向的变量值可变）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">10</span></span><br><span class="line">    p := &amp;x</span><br><span class="line">    <span class="comment">// 捕获指针 p（拷贝指针地址）</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;defer 捕获的 x：&quot;</span>, *p) </span><br><span class="line"></span><br><span class="line">    x = <span class="number">20</span> <span class="comment">// 修改指针指向的变量值，defer 输出会变化</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;main 中的 x：&quot;</span>, x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main 中的 x： 20</span><br><span class="line">defer 捕获的 x： 20 // 指针指向的值已修改</span><br></pre></td></tr></table></figure>

<p><strong>4. 支持函数调用、方法调用，也支持匿名函数</strong></p>
<p><code>defer</code> 后面可以跟：</p>
<ul>
<li>普通函数调用（如 <code>defer closeFile(f)</code>）；</li>
<li>方法调用（如 <code>defer f.Close()</code>）；</li>
<li>匿名函数（最灵活，支持复杂逻辑）。</li>
</ul>
<p>示例：匿名函数形式的 <code>defer</code>（带参数、带返回值）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := createFile(<span class="string">&quot;/tmp/defer.txt&quot;</span>)</span><br><span class="line">    <span class="comment">// 匿名函数形式的 defer，可直接处理错误、添加逻辑</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(file *os.File)</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;closing&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> err := file.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Fprintf(os.Stderr, <span class="string">&quot;close error: %v\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;(f) <span class="comment">// 此处传入 f 的拷贝值（注册时的文件句柄）</span></span><br><span class="line"></span><br><span class="line">    writeFile(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>defer</code> 的核心使用场景</strong></p>
<p><code>defer</code> 的设计初衷是「资源清理」，核心场景围绕「确保资源被释放，避免泄漏」：</p>
<p><strong>1. 文件 &#x2F; 网络连接 &#x2F; 数据库连接关闭</strong></p>
<p>这是最常用的场景 —— 打开文件、建立连接后，立即用 <code>defer</code> 注册关闭操作，避免后续忘记关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据库连接示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connectDB</span><span class="params">()</span></span> *sql.DB &#123;</span><br><span class="line">    db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;user:pass@tcp(127.0.0.1:3306)/dbname&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 延迟关闭数据库连接（main 退出前执行）</span></span><br><span class="line">    <span class="keyword">defer</span> db.Close() </span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 锁的释放（避免死锁）</strong></p>
<p>使用 <code>sync.Mutex</code> 等锁时，<code>Lock</code> 后立即 <code>defer Unlock</code>，确保无论中间逻辑是否出错，锁都会被释放。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mu.Lock()</span><br><span class="line">    <span class="comment">// 延迟释放锁，避免中间 panic 导致死锁</span></span><br><span class="line">    <span class="keyword">defer</span> mu.Unlock() </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 业务逻辑（即使发生 panic，锁也会被释放）</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;do something&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 日志记录 &#x2F; 统计（如接口耗时统计）</strong></p>
<p>用 <code>defer</code> 记录函数执行耗时，无需在函数末尾手动写统计代码，逻辑更简洁。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apiHandler</span><span class="params">()</span></span> &#123;</span><br><span class="line">    start := time.Now()</span><br><span class="line">    <span class="comment">// 延迟记录耗时（函数退出前执行）</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        cost := time.Since(start)</span><br><span class="line">        fmt.Printf(<span class="string">&quot;接口执行耗时：%v\n&quot;</span>, cost)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接口业务逻辑（如数据库查询、网络请求）</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4. <code>panic</code> 捕获（配合 <code>recover</code>）</strong></p>
<p><code>recover</code> 必须在 <code>defer</code> 函数中调用，才能捕获 <code>panic</code>，避免程序退出（后续会详细讲 <code>recover</code>，这里先记住场景）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeRun</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;捕获到 panic：%v\n&quot;</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;something wrong&quot;</span>) <span class="comment">// 会被 defer 中的 recover 捕获</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>defer</code> 的避坑指南</strong></p>
<p><strong>1. 避免在循环中注册 <code>defer</code>（可能导致资源泄漏）</strong></p>
<p>循环中注册 <code>defer</code> 时，<code>defer</code> 函数会在循环所在的函数（如 <code>main</code>）退出时才批量执行 —— 若循环次数多（如 1000 次打开文件），会导致大量文件句柄被占用，直到函数退出才释放，引发资源泄漏。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：1000 个文件句柄会被占用到 main 退出</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">badLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        f, err := os.Create(fmt.Sprintf(<span class="string">&quot;/tmp/file%d.txt&quot;</span>, i))</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="built_in">panic</span>(err)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">defer</span> f.Close() <span class="comment">// 循环中注册，1000 个 defer 会堆积</span></span><br><span class="line">        fmt.Fprintln(f, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正确做法（用函数包裹，<code>defer</code> 在子函数中执行）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：每个文件在子函数退出时立即关闭</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goodLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 用匿名函数包裹，每次循环创建独立的函数作用域</span></span><br><span class="line">        <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            f, err := os.Create(fmt.Sprintf(<span class="string">&quot;/tmp/file%d.txt&quot;</span>, i))</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(err)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">defer</span> f.Close() <span class="comment">// 子函数退出时立即关闭文件</span></span><br><span class="line">            fmt.Fprintln(f, <span class="string">&quot;data&quot;</span>)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 注意 <code>defer</code> 对 <code>return</code> 值的影响</strong></p>
<p><code>defer</code> 函数可以修改「命名返回值」的值 —— 因为 <code>return</code> 语句的执行逻辑是：先给返回值赋值，再执行 <code>defer</code> 函数，最后返回。</p>
<p>示例（命名返回值被 <code>defer</code> 修改）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命名返回值：result</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a, b <span class="type">int</span>)</span></span> (result <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        result += <span class="number">10</span> <span class="comment">// defer 函数修改返回值</span></span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> a + b <span class="comment">// 步骤：1. result = a+b；2. 执行 defer（result +=10）；3. 返回 result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(add(<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">// 输出：15（2+3=5，defer 加 10 后为 15）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 避免 <code>defer</code> 中执行耗时操作</strong></p>
<p><code>defer</code> 函数会阻塞当前函数退出，若 <code>defer</code> 中执行耗时操作（如网络请求、大数据处理），会导致函数退出变慢，影响性能。</p>
<h2 id="5-recover"><a href="#5-recover" class="headerlink" title="5.recover"></a>5.recover</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mayPanic</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注册 defer 匿名函数：会在 main 函数退出前执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="comment">// 调用 recover()：仅在 defer 函数中有效，用于捕获 panic</span></span><br><span class="line">       <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">          <span class="comment">//  捕获到 panic 后执行：打印错误信息（r 是 panic 传入的参数）</span></span><br><span class="line">          fmt.Println(<span class="string">&quot;Recovered. Error:\n&quot;</span>, r)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  调用 mayPanic，触发 panic（程序进入恐慌模式）</span></span><br><span class="line">    mayPanic()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这行代码不会执行：因为 panic 会终止当前流程，直接跳转到 defer 函数</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;After mayPanic()&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键现象</strong>：程序没有崩溃退出（退出状态码为 0），而是正常执行完 <code>defer</code> 函数后结束 ——<code>recover</code> 成功捕获了 <code>panic</code>，阻止了程序崩溃。</p>
<p><strong><code>recover</code> 的核心特性</strong></p>
<p><strong>1. 唯一有效场景：在 <code>defer</code> 匿名函数中调用</strong></p>
<p><code>recover</code> 只有在「<code>defer</code> 注册的函数（通常是匿名函数）中调用」时才有效 —— 单独调用、在非 <code>defer</code> 函数中调用，都无法捕获 <code>panic</code>。</p>
<p><strong>错误示例（无效用法）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 错误 1：直接调用 recover，无法捕获后续的 panic</span></span><br><span class="line">    <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;recover:&quot;</span>, r)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 错误 2：在非 defer 函数中调用 recover</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123; <span class="comment">// 无效，无法捕获 panic</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;recover:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>) <span class="comment">// 程序依然崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 返回值含义：捕获到 <code>panic</code> 则返回 <code>panic</code> 的参数，否则返回 <code>nil</code></strong></p>
<p><code>recover()</code> 的函数签名是 <code>func recover() interface&#123;&#125;</code>，返回值类型为 <code>interface&#123;&#125;</code>（可接收任意类型）：</p>
<ul>
<li>若捕获到 <code>panic</code>：返回 <code>panic</code> 传入的参数（如字符串、<code>error</code> 类型）；</li>
<li>若未捕获到 <code>panic</code>（程序正常执行）：返回 <code>nil</code>（因此代码中需要判断 <code>r != nil</code> 才处理异常）。</li>
</ul>
<p><strong>示例（捕获 <code>error</code> 类型的 <code>panic</code>）：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mayPanicWithError</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := fmt.Errorf(<span class="string">&quot;file not found&quot;</span>)</span><br><span class="line">    <span class="built_in">panic</span>(err) <span class="comment">// 传入 error 类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 类型断言，将 interface&#123;&#125; 转为 error 类型</span></span><br><span class="line">            <span class="keyword">if</span> err, ok := r.(<span class="type">error</span>); ok &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recovered error:&quot;</span>, err.Error()) <span class="comment">// 输出：Recovered error: file not found</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;Recovered unknown error:&quot;</span>, r)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    mayPanicWithError()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 捕获范围：仅能捕获当前协程（Goroutine）的 <code>panic</code></strong></p>
<p><code>recover</code> 无法跨协程捕获 <code>panic</code>—— 每个协程的 <code>panic</code> 只能由该协程内注册的 <code>defer</code>+<code>recover</code> 捕获。</p>
<p><strong>示例（跨协程 <code>panic</code> 无法捕获）：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 主协程的 defer+recover：只能捕获主协程的 panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;主协程 recover:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动子协程，内部触发 panic</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;子协程 panic&quot;</span>) <span class="comment">// 子协程的 panic，主协程的 recover 无法捕获</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 等待子协程执行</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;主协程继续执行&quot;</span>) <span class="comment">// 不会执行，因为子协程 panic 导致程序崩溃</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：在子协程内部注册 <code>defer+recover</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;子协程 recover:&quot;</span>, r) <span class="comment">// 输出：子协程 recover: 子协程 panic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;子协程 panic&quot;</span>)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p><strong>4. 捕获后效果：当前协程恢复正常执行，<code>panic</code> 不再向上传播</strong></p>
<p><code>recover</code> 捕获 <code>panic</code> 后，当前协程会从 <code>panic</code> 触发点跳转到 <code>defer</code> 函数，执行完 <code>defer</code> 后，协程继续执行（但 <code>panic</code> 触发点后续的代码依然不会执行）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;step 1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;recovered:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>) <span class="comment">// step 2：触发 panic</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;step 3&quot;</span>) <span class="comment">// 不会执行（被 panic 中断）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="comment">// recovered: a problem</span></span><br><span class="line"><span class="comment">// 程序正常退出（无崩溃）</span></span><br></pre></td></tr></table></figure>

<p><strong><code>recover</code> 的核心使用场景</strong></p>
<p><code>recover</code> 的设计初衷是「恢复程序的可控执行」，避免因局部异常导致整个程序崩溃，核心场景如下：</p>
<p><strong>1. 主协程兜底：防止程序因意外 <code>panic</code> 崩溃</strong></p>
<p>在 <code>main</code> 函数中注册 <code>defer+recover</code>，作为整个程序的「最后一道防线」—— 即使某个子协程忘记处理 <code>panic</code>（或发生不可预期的 <code>panic</code>），主协程的 <code>recover</code> 也能捕获（仅限主协程自身的 <code>panic</code>，子协程需单独处理），确保程序优雅退出（如记录日志、清理资源）。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 记录错误日志（实际工作中会用日志框架，如 zap、logrus）</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;程序发生未预期异常：%v\n&quot;</span>, r)</span><br><span class="line">            <span class="comment">// 清理全局资源（如关闭数据库连接、释放锁）</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;正在清理全局资源...&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行核心业务逻辑</span></span><br><span class="line">    runBusiness()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runBusiness</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 业务逻辑中可能触发意外 panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;意外错误：数据库连接超时&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2. 子协程异常隔离：避免单个子协程 <code>panic</code> 导致整个程序崩溃</strong></p>
<p>在启动子协程时，立即注册 <code>defer+recover</code>，确保子协程的 <code>panic</code> 被隔离在自身范围内，不影响主协程和其他子协程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 子协程自身的 defer+recover：隔离 panic</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Printf(<span class="string">&quot;子协程 %d 发生异常：%v，已恢复\n&quot;</span>, id, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;子协程 %d 开始工作\n&quot;</span>, id)</span><br><span class="line">    <span class="comment">// 模拟业务逻辑中的 panic</span></span><br><span class="line">    <span class="keyword">if</span> id == <span class="number">3</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;处理任务失败&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;子协程 %d 工作完成\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 启动 5 个协程，其中第 3 个会触发 panic</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> worker(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second) <span class="comment">// 等待所有协程执行</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;主协程继续运行，程序未崩溃&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">子协程 1 开始工作</span><br><span class="line">子协程 1 工作完成</span><br><span class="line">子协程 2 开始工作</span><br><span class="line">子协程 2 工作完成</span><br><span class="line">子协程 3 开始工作</span><br><span class="line">子协程 3 发生异常：处理任务失败，已恢复</span><br><span class="line">子协程 4 开始工作</span><br><span class="line">子协程 4 工作完成</span><br><span class="line">子协程 5 开始工作</span><br><span class="line">子协程 5 工作完成</span><br><span class="line">主协程继续运行，程序未崩溃</span><br></pre></td></tr></table></figure>

<p><strong>3. 框架 &#x2F; 库的异常处理：为调用者提供稳定的接口</strong></p>
<p>编写第三方框架或库时，若内部可能发生 <code>panic</code>，需用 <code>recover</code> 捕获，转为 <code>error</code> 类型返回给调用者 —— 避免因库内部的 <code>panic</code> 导致调用者的程序崩溃，提升库的稳定性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 库函数：提供给外部调用，内部可能触发 panic</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseJSON</span><span class="params">(jsonStr <span class="type">string</span>)</span></span> (<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// 捕获内部 panic，转为 error 返回</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;解析 JSON 时发生异常：%v\n&quot;</span>, r)</span><br><span class="line">            <span class="comment">// 这里需要用命名返回值，才能在 defer 中修改返回值（后续会讲）</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟 JSON 解析（假设 json.Unmarshal 内部可能 panic，实际不会，但示例用）</span></span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err) <span class="comment">// 模拟解析失败触发 panic</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化后（用命名返回值接收 recover 后的错误）：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseJSON</span><span class="params">(jsonStr <span class="type">string</span>)</span></span> (result <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">&quot;json parse failed: %v&quot;</span>, r) <span class="comment">// 修改命名返回值 err</span></span><br><span class="line">            result = <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> data <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal([]<span class="type">byte</span>(jsonStr), &amp;data); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    result = data</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者使用：</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonStr := <span class="string">`&#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 20`</span> <span class="comment">// 不完整的 JSON（会解析失败）</span></span><br><span class="line">    data, err := ParseJSON(jsonStr)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;调用库函数失败：&quot;</span>, err) <span class="comment">// 输出：调用库函数失败：json parse failed: invalid JSON at end of input</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;解析结果：&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>recover</code> 的避坑指南</strong></p>
<p><strong>1. 不要滥用 <code>recover</code>：仅捕获「可恢复的异常」</strong></p>
<p><code>recover</code> 不是「万能的异常屏蔽器」—— 不要用它捕获所有 <code>panic</code>（如逻辑断言失败、配置加载失败等致命错误），否则会掩盖程序的严重 bug，导致问题难以排查。</p>
<p><strong>推荐原则：</strong></p>
<ul>
<li>用 <code>recover</code> 捕获「预期内的、可恢复的异常」（如子协程任务处理失败、第三方接口调用超时）；</li>
<li>对于「不可恢复的致命错误」（如程序启动时配置加载失败、数据库连接初始化失败），应让 <code>panic</code> 触发程序崩溃，便于及时发现问题。</li>
</ul>
<p><strong>2. 注意 <code>recover</code> 与 <code>defer</code> 执行顺序的关系</strong></p>
<p>若同一函数中注册多个 <code>defer</code> 函数，<code>recover</code> 仅能捕获「在它之前触发的 <code>panic</code>」—— 因为 <code>defer</code> 是后进先出执行的。</p>
<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// defer 1：第一个注册，最后执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;recover 1:&quot;</span>, r) <span class="comment">// 能捕获 panic</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// defer 2：第二个注册，先执行</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;defer 2 执行&quot;</span>)</span><br><span class="line">        <span class="comment">// 这里没有 recover，panic 会继续向上传播</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;a problem&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defer 2 执行</span><br><span class="line">recover 1: a problem</span><br></pre></td></tr></table></figure>

<p><strong>示例：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. defer1：第一个注册，最后执行（保留 recover，但会失效）</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=== defer1 执行（第一个注册，最后执行）===&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123; <span class="comment">// 此处 r 会是 nil，因为 panic 已被 defer3 捕获</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;defer1 中 recover 捕获到：&quot;</span>, r)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;defer1 中 recover：未捕获到 panic（已被前面的 defer 捕获）&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. defer2：第二个注册，中间执行（无 recover）</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=== defer2 执行（第二个注册，中间执行）===&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. defer3：第三个注册，最先执行（添加 recover）</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;=== defer3 执行（第三个注册，最先执行）===&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123; <span class="comment">// 优先捕获 panic</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;defer3 中 recover 捕获到：&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 触发 panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;我是一个 panic！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;panic 后的代码&quot;</span>) <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=== defer3 执行（第三个注册，最先执行）===</span><br><span class="line">defer3 中 recover 捕获到： 我是一个 panic！</span><br><span class="line">=== defer2 执行（第二个注册，中间执行）===</span><br><span class="line">=== defer1 执行（第一个注册，最后执行）===</span><br><span class="line">defer1 中 recover：未捕获到 panic（已被前面的 defer 捕获）</span><br></pre></td></tr></table></figure>

<p><strong><code>recover</code> 优先捕获 <code>panic</code>，同一个 <code>panic</code> 只能被捕获一次，<code>recover</code> 不影响后续 <code>defer</code> 的执行：</strong></p>
<p><strong>3. <code>recover</code> 无法捕获 <code>os.Exit</code> 触发的退出</strong></p>
<p><code>os.Exit(code)</code> 会直接终止整个程序，跳过所有 <code>defer</code> 函数，因此 <code>recover</code> 无法捕获。</p>
<h2 id="6-字符串函数"><a href="#6-字符串函数" class="headerlink" title="6.字符串函数"></a>6.字符串函数</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="comment">// import s &quot;strings&quot; 是「包别名」用法：为 strings 包起短别名 s，后续调用函数时可简写 s.Contains（而非完整的 strings.Contains），更简洁；</span></span><br><span class="line">    s <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// var p = fmt.Println 是「函数变量赋值」：把 fmt.Println 赋值给变量 p，后续用 p(...) 等价于 fmt.Println(...)，减少重复代码；</span></span><br><span class="line"><span class="keyword">var</span> p = fmt.Println</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断字符串是否包含子串 substr</span></span><br><span class="line">    p(<span class="string">&quot;Contains:  &quot;</span>, s.Contains(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;es&quot;</span>))</span><br><span class="line">    <span class="comment">// 计子串 substr 在 s 中出现的非重叠次数</span></span><br><span class="line">    p(<span class="string">&quot;Count:     &quot;</span>, s.Count(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;t&quot;</span>))</span><br><span class="line">    <span class="comment">// 判断字符串是否以前缀 prefix 开头</span></span><br><span class="line">    p(<span class="string">&quot;HasPrefix: &quot;</span>, s.HasPrefix(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;te&quot;</span>))</span><br><span class="line">    <span class="comment">// 判断字符串是否以后缀 suffix 结尾</span></span><br><span class="line">    p(<span class="string">&quot;HasSuffix: &quot;</span>, s.HasSuffix(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;st&quot;</span>))</span><br><span class="line">    <span class="comment">// 查找子串 substr在「首次出现的起始索引」</span></span><br><span class="line">    p(<span class="string">&quot;Index:     &quot;</span>, s.Index(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;e&quot;</span>))</span><br><span class="line">    <span class="comment">// 将字符串切片 用分隔符  拼接成一个字符串</span></span><br><span class="line">    p(<span class="string">&quot;Join:      &quot;</span>, s.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>&#125;, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    <span class="comment">// 将字符串重复 count 次，返回新字符串</span></span><br><span class="line">    p(<span class="string">&quot;Repeat:    &quot;</span>, s.Repeat(<span class="string">&quot;a&quot;</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    将 s 中 old 子串替换为 new，替换 n 次</span></span><br><span class="line"><span class="comment">       1. n=-1 表示「全部替换」；</span></span><br><span class="line"><span class="comment">       2. n=1 表示「只替换首次出现的子串」（如第二个示例返回 &quot;f0o&quot;）；</span></span><br><span class="line"><span class="comment">       3. 若 old 不存在，返回原字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    p(<span class="string">&quot;Replace:   &quot;</span>, s.Replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="number">-1</span>))</span><br><span class="line">    p(<span class="string">&quot;Replace:   &quot;</span>, s.Replace(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;o&quot;</span>, <span class="string">&quot;0&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// 用分隔符将 s 拆分为字符串切片</span></span><br><span class="line">    p(<span class="string">&quot;Split:     &quot;</span>, s.Split(<span class="string">&quot;a-b-c-d-e&quot;</span>, <span class="string">&quot;-&quot;</span>))</span><br><span class="line">    <span class="comment">//  将 s 中所有字符转为小写</span></span><br><span class="line">    p(<span class="string">&quot;ToLower:   &quot;</span>, s.ToLower(<span class="string">&quot;TEST&quot;</span>))</span><br><span class="line">    <span class="comment">// 将 s 中所有字符转为大写</span></span><br><span class="line">    p(<span class="string">&quot;ToUpper:   &quot;</span>, s.ToUpper(<span class="string">&quot;test&quot;</span>))</span><br><span class="line">    p()</span><br><span class="line"></span><br><span class="line">    p(<span class="string">&quot;Len: &quot;</span>, <span class="built_in">len</span>(<span class="string">&quot;hello&quot;</span>))</span><br><span class="line">    p(<span class="string">&quot;Char:&quot;</span>, <span class="string">&quot;hello&quot;</span>[<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<ol>
<li><strong>字符串不可变</strong>：所有 <code>strings</code> 包函数都返回新字符串，原字符串不会被修改（如 <code>s := &quot;foo&quot;; s.Replace(&quot;o&quot;, &quot;0&quot;, -1)</code> 后，<code>s</code> 依然是 <code>&quot;foo&quot;</code>，需用变量接收新结果：<code>newS := s.Replace(...)</code>）；</li>
<li><strong>区分大小写</strong>：默认所有函数都区分大小写（如 <code>Contains(&quot;Test&quot;, &quot;test&quot;)</code> 返回 <code>false</code>），若需忽略大小写，需先统一转为大写 &#x2F; 小写再操作（如 <code>strings.ToLower(s) == strings.ToLower(target)</code>）；</li>
<li><strong>UTF-8 编码兼容</strong>：<code>strings</code> 包函数支持 UTF-8 编码（如中文、特殊字符），但 <code>len</code> 和索引访问是按字节处理的，多字节字符需用 <code>[]rune</code> 转换后操作；</li>
<li><strong>空字符串处理</strong>：函数对空字符串（<code>&quot;&quot;</code>）兼容（如 <code>Contains(&quot;&quot;, &quot;&quot;)</code> 返回 <code>true</code>，<code>Split(&quot;&quot;, &quot;-&quot;)</code> 返回 <code>[]string&#123;&#125;</code>），不会 panic。</li>
</ol>
<h2 id="7-字符串格式化"><a href="#7-字符串格式化" class="headerlink" title="7.字符串格式化"></a>7.字符串格式化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> point <span class="keyword">struct</span> &#123;</span><br><span class="line">    x, y <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    p := point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;struct1: %v\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;struct2: %+v\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;struct3: %#v\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;type: %T\n&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;bool: %t\n&quot;</span>, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;int: %d\n&quot;</span>, <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;bin: %b\n&quot;</span>, <span class="number">14</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;char: %c\n&quot;</span>, <span class="number">33</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;hex: %x\n&quot;</span>, <span class="number">456</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;float1: %f\n&quot;</span>, <span class="number">78.9</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;float2: %e\n&quot;</span>, <span class="number">123400000.0</span>)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;float3: %E\n&quot;</span>, <span class="number">123400000.0</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;str1: %s\n&quot;</span>, <span class="string">&quot;\&quot;string\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;str2: %q\n&quot;</span>, <span class="string">&quot;\&quot;string\&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;str3: %x\n&quot;</span>, <span class="string">&quot;hex this&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;pointer: %p\n&quot;</span>, &amp;p)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;width1: |%6d|%6d|\n&quot;</span>, <span class="number">12</span>, <span class="number">345</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;width2: |%6.2f|%6.2f|\n&quot;</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;width3: |%-6.2f|%-6.2f|\n&quot;</span>, <span class="number">1.2</span>, <span class="number">3.45</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;width4: |%6s|%6s|\n&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;width5: |%-6s|%-6s|\n&quot;</span>, <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;b&quot;</span>)</span><br><span class="line"></span><br><span class="line">    s := fmt.Sprintf(<span class="string">&quot;sprintf: a %s&quot;</span>, <span class="string">&quot;string&quot;</span>)</span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(os.Stderr, <span class="string">&quot;io: an %s\n&quot;</span>, <span class="string">&quot;error&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>逐类解读格式化动词</strong></p>
<p><strong>1. 结构体 &#x2F; 任意类型打印（<code>%v</code> 系列：最常用）</strong></p>
<p>用于打印任意类型（尤其是结构体），灵活度最高，分 3 种变体：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>功能描述</th>
<th>示例代码</th>
<th>输出结果</th>
<th>关键细节</th>
</tr>
</thead>
<tbody><tr>
<td><code>%v</code></td>
<td>「默认格式」打印值：结构体打印字段值，基础类型打印原值</td>
<td><code>fmt.Printf(&quot;%v&quot;, p)</code></td>
<td><code>&#123;1 2&#125;</code></td>
<td>不显示字段名，适合快速查看值；基础类型（如 int、string）与直接打印一致</td>
</tr>
<tr>
<td><code>%+v</code></td>
<td>「详细格式」打印值：结构体额外显示字段名</td>
<td><code>fmt.Printf(&quot;%+v&quot;, p)</code></td>
<td><code>&#123;x:1 y:2&#125;</code></td>
<td>结构体调试必备，清晰区分字段与值</td>
</tr>
<tr>
<td><code>%#v</code></td>
<td>「Go 语法格式」打印值：输出可直接编译的 Go 代码</td>
<td><code>fmt.Printf(&quot;%#v&quot;, p)</code></td>
<td><code>main.point&#123;x:1, y:2&#125;</code></td>
<td>不仅显示字段名，还显示类型名，复制输出可直接作为 Go 代码使用（调试时快速复现数据）</td>
</tr>
</tbody></table>
<p><strong>补充动词</strong>：<code>%T</code>（显示变量类型，非打印值）：</p>
<ul>
<li>示例：<code>fmt.Printf(&quot;%T&quot;, p)</code> → 输出 <code>main.point</code>（明确变量是 <code>main</code> 包下的 <code>point</code> 类型）；</li>
<li>用途：调试时确认变量类型（如判断接口变量的实际类型）。</li>
</ul>
<p><strong>2. 布尔 &#x2F; 整数类型格式化</strong></p>
<table>
<thead>
<tr>
<th>动词</th>
<th>功能描述</th>
<th>示例代码</th>
<th>输出结果</th>
<th>关键细节</th>
</tr>
</thead>
<tbody><tr>
<td><code>%t</code></td>
<td>打印布尔值：<code>true</code> 或 <code>false</code>（小写）</td>
<td><code>fmt.Printf(&quot;%t&quot;, true)</code></td>
<td><code>true</code></td>
<td>仅用于布尔类型，其他类型会报错（如 <code>%t</code> 对应 int 会输出 <code>%!t(int=123)</code>）</td>
</tr>
<tr>
<td><code>%d</code></td>
<td>打印十进制整数（默认）</td>
<td><code>fmt.Printf(&quot;%d&quot;, 123)</code></td>
<td><code>123</code></td>
<td>最常用的整数格式，支持正数、负数、零</td>
</tr>
<tr>
<td><code>%b</code></td>
<td>打印二进制整数（0b 前缀可选，默认无）</td>
<td><code>fmt.Printf(&quot;%b&quot;, 14)</code></td>
<td><code>1110</code></td>
<td>14 的二进制是 1110，适合底层调试（如位运算结果查看）</td>
</tr>
<tr>
<td><code>%c</code></td>
<td>打印整数对应的「Unicode 字符」</td>
<td><code>fmt.Printf(&quot;%c&quot;, 33)</code></td>
<td><code>!</code></td>
<td>33 是 <code>!</code> 的 ASCII 码（Unicode 码点），支持中文（如 <code>%c</code> 对应 20320 输出 <code>你</code>）</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>打印十六进制整数（小写字母 a-f）</td>
<td><code>fmt.Printf(&quot;%x&quot;, 456)</code></td>
<td><code>1c8</code></td>
<td>456 转十六进制是 1C8，小写更常用；大写用 <code>%X</code>（输出 <code>1C8</code>）</td>
</tr>
</tbody></table>
<p><strong>补充整数动词</strong>（高频）：</p>
<ul>
<li><code>%o</code>：八进制整数；</li>
<li><code>%U</code>：Unicode 码点（如 <code>%U</code> 对应 33 输出 <code>U+0021</code>）。</li>
</ul>
<p><strong>3. 浮点数 &#x2F; 科学计数法格式化</strong></p>
<p>用于打印 <code>float32</code>&#x2F;<code>float64</code> 类型，控制小数位数和计数法：</p>
<table>
<thead>
<tr>
<th>动词</th>
<th>功能描述</th>
<th>示例代码</th>
<th>输出结果</th>
<th>关键细节</th>
</tr>
</thead>
<tbody><tr>
<td><code>%f</code></td>
<td>「固定小数格式」打印浮点数（默认 6 位小数）</td>
<td><code>fmt.Printf(&quot;%f&quot;, 78.9)</code></td>
<td><code>78.900000</code></td>
<td>可通过 <code>%m.nf</code> 控制宽度和小数位数（如 <code>%6.2f</code> 表示总宽度 6，小数 2 位）</td>
</tr>
<tr>
<td><code>%e</code></td>
<td>「小写科学计数法」打印（如 1.23e+08）</td>
<td><code>fmt.Printf(&quot;%e&quot;, 123400000.0)</code></td>
<td><code>1.234000e+08</code></td>
<td>适合表示极大 &#x2F; 极小的浮点数，<code>e</code> 是小写</td>
</tr>
<tr>
<td><code>%E</code></td>
<td>「大写科学计数法」打印（如 1.23E+08）</td>
<td><code>fmt.Printf(&quot;%E&quot;, 123400000.0)</code></td>
<td><code>1.234000E+08</code></td>
<td>与 <code>%e</code> 功能一致，仅 <code>E</code> 是大写，用于统一输出格式</td>
</tr>
</tbody></table>
<p><strong>关键细节</strong>：<code>%f</code> 的小数位数控制（如 <code>%6.2f</code>）：</p>
<ul>
<li>总宽度 <code>6</code>：包括整数部分、小数点、小数部分（不足补空格，默认右对齐）；</li>
<li>小数位数 <code>2</code>：强制保留 2 位小数（如 1.2 → 1.20，3.456 → 3.46，四舍五入）。</li>
</ul>
<p><strong>4. 字符串 &#x2F; 字节格式化</strong></p>
<table>
<thead>
<tr>
<th>动词</th>
<th>功能描述</th>
<th>示例代码</th>
<th>输出结果</th>
<th>关键细节</th>
</tr>
</thead>
<tbody><tr>
<td><code>%s</code></td>
<td>打印字符串（原样输出，不转义）</td>
<td><code>fmt.Printf(&quot;%s&quot;, &quot;\&quot;string\&quot;&quot;)</code></td>
<td><code>&quot;string&quot;</code></td>
<td>直接输出字符串内容，包括特殊字符（如引号、换行符 <code>\n</code>）</td>
</tr>
<tr>
<td><code>%q</code></td>
<td>打印字符串并添加「双引号」，同时转义特殊字符</td>
<td><code>fmt.Printf(&quot;%q&quot;, &quot;\&quot;string\&quot;&quot;)</code></td>
<td><code>&quot;\&quot;string\&quot;&quot;</code></td>
<td>自动转义字符串中的引号（<code>&quot;</code> → <code>\&quot;</code>）、换行符（<code>\n</code>）等，适合调试字符串（明确字符串边界和特殊字符）</td>
</tr>
<tr>
<td><code>%x</code></td>
<td>打印字符串的「十六进制编码」（按字节）</td>
<td><code>fmt.Printf(&quot;%x&quot;, &quot;hex this&quot;)</code></td>
<td><code>6865782074686973</code></td>
<td>每个字符对应 2 位十六进制（如 <code>h</code> → 68，<code>e</code> → 65），用于字符串加密 &#x2F; 校验</td>
</tr>
</tbody></table>
<p><strong>补充字符串动词</strong>：<code>%q</code> 对非字符串类型的处理：</p>
<ul>
<li>若 <code>%q</code> 对应整数，会输出该整数对应的 Unicode 字符加引号（如 <code>%q</code> 对应 33 → <code>&quot;!&quot;</code>）。</li>
</ul>
<p><strong>5. 指针格式化（<code>%p</code>）</strong></p>
<table>
<thead>
<tr>
<th>动词</th>
<th>功能描述</th>
<th>示例代码</th>
<th>输出结果</th>
<th>关键细节</th>
</tr>
</thead>
<tbody><tr>
<td><code>%p</code></td>
<td>打印指针的「十六进制内存地址」（带 0x 前缀）</td>
<td><code>fmt.Printf(&quot;%p&quot;, &amp;p)</code></td>
<td><code>0xc0000a6020</code>（因人而异）</td>
<td>输出的是变量的内存地址，每次运行可能不同；仅用于调试（如确认指针是否为 nil）</td>
</tr>
</tbody></table>
<p><strong>注意</strong>：<code>%p</code> 仅接收指针类型参数（如 <code>&amp;p</code>），若传入非指针（如 <code>p</code>），会输出 <code>%!p(main.point=&#123;1 2&#125;)</code> 格式错误。</p>
<p><strong>6. 宽度与对齐控制（修饰符：<code>%[宽度].[精度]动词</code>）</strong></p>
<p>通过在动词前添加「宽度」「精度」「对齐符」，控制输出的格式整齐度（常用于表格化输出）：</p>
<table>
<thead>
<tr>
<th>格式语法</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>%[宽度]d</code></td>
<td>整数固定宽度，默认右对齐（不足补空格）</td>
</tr>
<tr>
<td><code>%[宽度].[精度]f</code></td>
<td>浮点数固定总宽度 + 小数位数，默认右对齐（不足补空格）</td>
</tr>
<tr>
<td><code>%-[宽度].[精度]f</code></td>
<td>浮点数固定总宽度 + 小数位数，左对齐（<code>-</code> 表示左对齐，不足补空格到右侧）</td>
</tr>
<tr>
<td><code>%[宽度]s</code></td>
<td>字符串固定宽度，默认右对齐（不足补空格到左侧）</td>
</tr>
<tr>
<td><code>%-[宽度]s</code></td>
<td>字符串固定宽度，左对齐（不足补空格到右侧）</td>
</tr>
</tbody></table>
<p><strong>核心规则</strong>：</p>
<ul>
<li>宽度：指输出字符串的总长度（包括数字、小数点、字母、空格等）；</li>
<li>精度：对浮点数是「小数位数」，对字符串是「最大显示长度」（如 <code>%.2s</code> 表示只显示前 2 个字符）；</li>
<li>左对齐：默认右对齐，添加 <code>-</code> 后改为左对齐（空格补在后面）。</li>
</ul>
<p><strong>四、三大格式化函数详解</strong></p>
<p>代码最后演示了 <code>fmt</code> 包的三个核心格式化函数，覆盖「打印、拼接、IO 写入」：</p>
<p><strong>1. <code>fmt.Sprintf</code>：格式化并返回字符串（不打印）</strong></p>
<ul>
<li>功能：将格式化后的字符串作为返回值返回，需用变量接收，后续可用于存储、传递或二次处理；</li>
<li>示例：<code>s := fmt.Sprintf(&quot;sprintf: a %s&quot;, &quot;string&quot;)</code> → 变量 <code>s</code> 的值是 <code>&quot;sprintf: a string&quot;</code>；</li>
<li>场景：拼接复杂字符串（如构造 URL、日志内容），避免多次使用 <code>+</code> 拼接（效率低、可读性差）。</li>
</ul>
<p><strong>2. <code>fmt.Fprintf</code>：格式化并写入 IO 流</strong></p>
<ul>
<li>功能：将格式化后的字符串写入指定的 <code>io.Writer</code> 接口（如 <code>os.Stderr</code>、文件、网络连接）；</li>
<li>示例：<code>fmt.Fprintf(os.Stderr, &quot;io: an %s\n&quot;, &quot;error&quot;)</code> → 写入标准错误流（<code>os.Stderr</code>）；</li>
<li>场景：输出错误信息（标准错误流与标准输出流分离，便于日志分类）、写入文件 &#x2F; 网络（如向 TCP 连接发送格式化数据）。</li>
</ul>
<p><strong>3. <code>fmt.Printf</code>：格式化并打印到标准输出</strong></p>
<ul>
<li>功能：最常用的函数，直接打印到标准输出（终端），无需接收返回值；</li>
<li>场景：调试输出、用户交互提示（如命令行工具的输出）。</li>
</ul>
<p><strong>五、核心注意点</strong></p>
<ol>
<li><strong>动词与参数类型匹配</strong>：<ul>
<li>错误示例：<code>fmt.Printf(&quot;%d&quot;, &quot;abc&quot;)</code> → 输出 <code>%!d(string=abc)</code>（类型不匹配，不会 panic，但输出错误信息）；</li>
<li>原则：<code>%d</code> 对应整数，<code>%s</code> 对应字符串，<code>%f</code> 对应浮点数，严格匹配避免格式错误。</li>
</ul>
</li>
<li><strong>字符串是不可变类型</strong>：<ul>
<li>所有格式化函数都会返回新字符串（或直接输出），不会修改原变量（如 <code>Sprintf</code> 不会改变输入的参数值）。</li>
</ul>
</li>
<li><strong>宽度与精度的默认值</strong>：<ul>
<li>宽度默认无限制（按实际长度输出）；</li>
<li>浮点数 <code>%f</code> 默认精度 6 位，字符串 <code>%s</code> 默认精度无限制（显示完整字符串）。</li>
</ul>
</li>
<li><strong>特殊字符的转义</strong>：<ul>
<li>格式化字符串中若需显示 <code>%</code>，需用 <code>%%</code> 转义（如 <code>fmt.Printf(&quot;百分比：%d%%&quot;, 50)</code> → 输出 <code>百分比：50%</code>）；</li>
<li>字符串中的引号、换行符等，可用 <code>\</code> 转义（如 <code>\&quot;</code> 表示双引号，<code>\n</code> 表示换行）。</li>
</ul>
</li>
</ol>
<h2 id="8-文本模板"><a href="#8-文本模板" class="headerlink" title="8.文本模板"></a>8.文本模板</h2><p><strong>核心概念</strong></p>
<ol>
<li><strong>模板（Template）</strong>：包含「固定文本」和「动态占位符（<code>&#123;&#123; &#125;&#125;</code> 包裹）」的字符串，占位符会被实际数据替换，最终生成个性化文本；</li>
<li><strong>数据（Data）</strong>：传递给模板的变量（可以是字符串、整数、切片、结构体、字典等），模板中通过 <code>.</code>（点）或字段名访问；</li>
<li><strong>渲染（Execute）</strong>：将数据注入模板，替换占位符，生成最终文本并输出（如输出到终端、文件、网络流）；</li>
<li><strong>关键函数：</strong><ul>
<li><code>template.New(name)</code>：创建一个新模板（<code>name</code> 是模板名称，用于调试）；</li>
<li><code>template.Parse(tplStr)</code>：解析模板字符串（将占位符、语法标记解析为可执行的模板结构）；</li>
<li><code>template.Must(tpl *Template, err error)</code>：简化错误处理（若解析出错直接 <code>panic</code>，避免重复写 <code>if err != nil</code>）；</li>
<li><code>tpl.Execute(w io.Writer, data interface&#123;&#125;)</code>：渲染模板，将结果写入指定 IO 流（如 <code>os.Stdout</code> 终端）。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;text/template&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建名为 &quot;t1&quot; 的空模板</span></span><br><span class="line">    t1 := template.New(<span class="string">&quot;t1&quot;</span>)</span><br><span class="line">    <span class="comment">// 解析模板字符串：&#123;&#123;.&#125;&#125; 是「当前数据」的占位符</span></span><br><span class="line">    t1, err := t1.Parse(<span class="string">&quot;Value is &#123;&#123;.&#125;&#125;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新解析模板（覆盖之前的内容）：用 template.Must 简化错误处理</span></span><br><span class="line">    t1 = template.Must(t1.Parse(<span class="string">&quot;Value: &#123;&#123;.&#125;&#125;\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  渲染模板：传递不同类型的数据，&#123;&#123;.&#125;&#125; 会自动适配数据格式</span></span><br><span class="line">    t1.Execute(os.Stdout, <span class="string">&quot;some text&quot;</span>) <span class="comment">// 数据：字符串 → 输出 Value: some text</span></span><br><span class="line">    t1.Execute(os.Stdout, <span class="number">5</span>)           <span class="comment">// 数据：整数 → 输出 Value: 5</span></span><br><span class="line">    t1.Execute(os.Stdout, []<span class="type">string</span>&#123;    <span class="comment">// 数据：切片 → 输出 Value: [Go Rust C++ C#]</span></span><br><span class="line">       <span class="string">&quot;Go&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Rust&quot;</span>,</span><br><span class="line">       <span class="string">&quot;C++&quot;</span>,</span><br><span class="line">       <span class="string">&quot;C#&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义函数：接收模板名称和模板字符串，返回解析后的模板（自动处理错误）</span></span><br><span class="line">    Create := <span class="function"><span class="keyword">func</span><span class="params">(name, t <span class="type">string</span>)</span></span> *template.Template &#123;</span><br><span class="line">       <span class="keyword">return</span> template.Must(template.New(name).Parse(t))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模板 t2：&#123;&#123;.Name&#125;&#125; 访问数据的 Name 字段/键</span></span><br><span class="line">    t2 := Create(<span class="string">&quot;t2&quot;</span>, <span class="string">&quot;Name: &#123;&#123;.Name&#125;&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染 1：传递匿名结构体（有 Name 字段）</span></span><br><span class="line">    t2.Execute(os.Stdout, <span class="keyword">struct</span> &#123;</span><br><span class="line">       Name <span class="type">string</span></span><br><span class="line">    &#125;&#123;<span class="string">&quot;Jane Doe&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染 2：传递字典（map[string]string，有 Name 键）</span></span><br><span class="line">    t2.Execute(os.Stdout, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">       <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Mickey Mouse&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模板 t3：条件判断语法（&#123;&#123;if .&#125;&#125; 判空，&#123;&#123;-&#125;&#125; 去除多余空格）</span></span><br><span class="line">    t3 := Create(<span class="string">&quot;t3&quot;</span>,</span><br><span class="line">       <span class="string">&quot;&#123;&#123;if . -&#125;&#125; yes &#123;&#123;else -&#125;&#125; no &#123;&#123;end&#125;&#125;\n&quot;</span>)</span><br><span class="line">    t3.Execute(os.Stdout, <span class="string">&quot;not empty&quot;</span>)</span><br><span class="line">    t3.Execute(os.Stdout, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建模板 t4：range 遍历切片/字典，&#123;&#123;.&#125;&#125; 表示遍历到的当前元素</span></span><br><span class="line">    t4 := Create(<span class="string">&quot;t4&quot;</span>,</span><br><span class="line">       <span class="string">&quot;Range: &#123;&#123;range .&#125;&#125;&#123;&#123;.&#125;&#125; &#123;&#123;end&#125;&#125;\n&quot;</span>)</span><br><span class="line">    t4.Execute(os.Stdout,</span><br><span class="line">       []<span class="type">string</span>&#123;</span><br><span class="line">          <span class="string">&quot;Go&quot;</span>,</span><br><span class="line">          <span class="string">&quot;Rust&quot;</span>,</span><br><span class="line">          <span class="string">&quot;C++&quot;</span>,</span><br><span class="line">          <span class="string">&quot;C#&quot;</span>,</span><br><span class="line">       &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心语法</strong></p>
<p><strong>1. 基础模板：创建、解析与简单渲染（<code>t1</code> 模板）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t1 := template.New(<span class="string">&quot;t1&quot;</span>)</span><br><span class="line"></span><br><span class="line">t1, err := t1.Parse(<span class="string">&quot;Value is &#123;&#123;.&#125;&#125;\n&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t1 = template.Must(t1.Parse(<span class="string">&quot;Value: &#123;&#123;.&#125;&#125;\n&quot;</span>))</span><br><span class="line"></span><br><span class="line">t1.Execute(os.Stdout, <span class="string">&quot;some text&quot;</span>) </span><br><span class="line">t1.Execute(os.Stdout, <span class="number">5</span>)          </span><br><span class="line">t1.Execute(os.Stdout, []<span class="type">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong><code>&#123;&#123;.&#125;&#125;</code></strong></p>
<ul>
<li>表示「当前上下文数据」（即 <code>Execute</code> 传入的第二个参数）；</li>
<li>模板会自动根据数据类型格式化输出（字符串原样显示、整数直接打印、切片显示为 <code>[元素1 元素2]</code> 格式）；</li>
<li>注意：<code>Parse</code> 会覆盖模板内容（第二次 <code>Parse</code> 后，模板内容是 <code>Value: &#123;&#123;.&#125;&#125;\n</code>，而非第一次的 <code>Value is &#123;&#123;.&#125;&#125;\n</code>）。</li>
</ul>
<p><strong><code>template.Must</code> 作用</strong></p>
<p>解析模板时若出错（如语法错误），直接 <code>panic</code>，避免写重复的 <code>if err != nil</code> 判断，适合「确定模板语法正确」的场景（如硬编码的模板）。</p>
<p><strong>2. 自定义工具函数：简化模板创建（<code>Create</code> 函数）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Create := <span class="function"><span class="keyword">func</span><span class="params">(name, t <span class="type">string</span>)</span></span> *template.Template &#123;</span><br><span class="line">    <span class="keyword">return</span> template.Must(template.New(name).Parse(t))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>：封装「创建模板 + 解析模板 + 错误处理」的重复逻辑，后续创建模板时直接调用 <code>Create</code>，代码更简洁（如后面的 <code>t2</code>、<code>t3</code>、<code>t4</code> 模板）。</p>
<p><strong>3. 字段访问：绑定结构体 &#x2F; 字典数据（<code>t2</code> 模板）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t2 := Create(<span class="string">&quot;t2&quot;</span>, <span class="string">&quot;Name: &#123;&#123;.Name&#125;&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">t2.Execute(os.Stdout, <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;Jane Doe&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">t2.Execute(os.Stdout, <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;Name&quot;</span>: <span class="string">&quot;Mickey Mouse&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong><code>&#123;&#123;.FieldName&#125;&#125;</code></strong></p>
<p>用于访问「复合数据类型」的字段或键：</p>
<ul>
<li>结构体：访问 <code>FieldName</code> 字段（字段名首字母必须大写，否则模板无法访问，因为 Go 中小写字段是包私有）；</li>
<li>字典：访问 <code>FieldName</code> 对应的键值（字典的键必须是字符串，且与模板中的字段名完全匹配）；</li>
</ul>
<p>若数据没有对应的字段 &#x2F; 键，模板会输出空字符串（不会 <code>panic</code>）。</p>
<p><strong>4. 条件判断：<code>if-else</code> 语法（<code>t3</code> 模板）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建模板 t3：条件判断语法（&#123;&#123;if .&#125;&#125; 判空，&#123;&#123;-&#125;&#125; 去除多余空格）</span></span><br><span class="line">t3 := Create(<span class="string">&quot;t3&quot;</span>, <span class="string">&quot;&#123;&#123;if . -&#125;&#125; yes &#123;&#123;else -&#125;&#125; no &#123;&#123;end&#125;&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">t3.Execute(os.Stdout, <span class="string">&quot;not empty&quot;</span>) <span class="comment">// 数据非空为真 → 输出 yes</span></span><br><span class="line">t3.Execute(os.Stdout, <span class="string">&quot;&quot;</span>)          <span class="comment">// 数据为空为假 → 输出 no</span></span><br></pre></td></tr></table></figure>

<p><strong><code>&#123;&#123;if 条件&#125;&#125; 内容1 &#123;&#123;else&#125;&#125; 内容2 &#123;&#123;end&#125;&#125;</code></strong></p>
<ol>
<li>条件判断规则：<ul>
<li>布尔值：<code>true</code> 为真，<code>false</code> 为假；</li>
<li>字符串：非空为真，空字符串（<code>&quot;&quot;</code>）为假；</li>
<li>数值：非零为真，零为假；</li>
<li>切片 &#x2F; 字典 &#x2F; 指针：非 <code>nil</code> 且长度 &gt; 0 为真（<code>nil</code> 或长度 &#x3D; 0 为假）；</li>
</ul>
</li>
<li><code>&#123;&#123;-&#125;&#125;</code> 作用：去除模板中多余的空格和换行（<code>-</code>会 “修剪” 其一侧的空白字符）；若不加 <code>&#123;&#123;-&#125;&#125;</code>，模板会输出 <code>yes</code>（前后有空格），加了之后输出 <code>yes</code>（无多余空格）；</li>
<li><strong><code>end</code> 必须存在</strong>：<code>if-else</code> 块必须用 <code>&#123;&#123;end&#125;&#125;</code> 闭合，否则解析模板会报错。</li>
</ol>
<p><strong>5. 循环遍历：<code>range</code> 语法（<code>t4</code> 模板）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t4 := Create(<span class="string">&quot;t4&quot;</span>, <span class="string">&quot;Range: &#123;&#123;range .&#125;&#125;&#123;&#123;.&#125;&#125; &#123;&#123;end&#125;&#125;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">t4.Execute(os.Stdout, []<span class="type">string</span>&#123;<span class="string">&quot;Go&quot;</span>, <span class="string">&quot;Rust&quot;</span>, <span class="string">&quot;C++&quot;</span>, <span class="string">&quot;C#&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>核心语法</strong>：<code>&#123;&#123;range 集合&#125;&#125; 元素处理 &#123;&#123;end&#125;&#125;</code></p>
<ol>
<li><strong>适用集合</strong>：切片（<code>[]T</code>）、数组（<code>[n]T</code>）、字典（<code>map[K]V</code>）、通道（<code>chan T</code>）；</li>
<li><strong>遍历逻辑：</strong><ul>
<li>切片 &#x2F; 数组：按顺序遍历每个元素，<code>&#123;&#123;.&#125;&#125;</code> 表示当前元素；</li>
<li>字典：遍历键值对，<code>&#123;&#123;.Key&#125;&#125;</code> 表示键，<code>&#123;&#123;.Value&#125;&#125;</code> 表示值（如 <code>&#123;&#123;range .&#125;&#125;&#123;&#123;.Key&#125;&#125;:&#123;&#123;.Value&#125;&#125; &#123;&#123;end&#125;&#125;</code>）；</li>
</ul>
</li>
<li><strong>空集合处理</strong>：若集合为空（如空切片、空字典），<code>range</code> 块内的内容不会输出；</li>
<li><strong>可选语法</strong>：<code>&#123;&#123;range .&#125;&#125; 内容 &#123;&#123;else&#125;&#125; 空集合时显示 &#123;&#123;end&#125;&#125;</code>（空集合时执行 <code>else</code> 块）。</li>
</ol>
<p><strong>核心语法总结</strong></p>
<table>
<thead>
<tr>
<th>语法</th>
<th>功能描述</th>
<th>示例</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#123;&#123;.&#125;&#125;</code></td>
<td>访问当前上下文数据</td>
<td><code>Value: &#123;&#123;.&#125;&#125;</code></td>
<td>简单数据渲染（字符串、整数）</td>
</tr>
<tr>
<td><code>&#123;&#123;.Field&#125;&#125;</code></td>
<td>访问结构体字段 &#x2F; 字典键</td>
<td><code>Name: &#123;&#123;.Name&#125;&#125;</code></td>
<td>复合数据（结构体、字典）</td>
</tr>
<tr>
<td><code>&#123;&#123;if 条件&#125;&#125;...&#123;&#123;else&#125;&#125;...&#123;&#123;end&#125;&#125;</code></td>
<td>条件判断</td>
<td><code>&#123;&#123;if .&#125;&#125;yes&#123;&#123;else&#125;&#125;no&#123;&#123;end&#125;&#125;</code></td>
<td>按数据是否为空 &#x2F; 为真分支显示</td>
</tr>
<tr>
<td><code>&#123;&#123;range 集合&#125;&#125;...&#123;&#123;end&#125;&#125;</code></td>
<td>遍历集合（切片 &#x2F; 数组 &#x2F; 字典）</td>
<td><code>&#123;&#123;range .&#125;&#125;&#123;&#123;.&#125;&#125; &#123;&#123;end&#125;&#125;</code></td>
<td>批量渲染列表数据</td>
</tr>
<tr>
<td><code>&#123;&#123;- ... -&#125;&#125;</code></td>
<td>修剪前后空白字符（换行、空格）</td>
<td><code>&#123;&#123;if . -&#125;&#125;yes&#123;&#123;- else&#125;&#125;no&#123;&#123;- end&#125;&#125;</code></td>
<td>格式化输出，避免多余空白</td>
</tr>
<tr>
<td><code>template.Must</code></td>
<td>简化模板解析错误处理</td>
<td><code>template.Must(t.Parse(&quot;...&quot;))</code></td>
<td>硬编码模板，无需手动处理错误</td>
</tr>
</tbody></table>
<h2 id="9-正则表达式"><a href="#9-正则表达式" class="headerlink" title="9.正则表达式"></a>9.正则表达式</h2><p><strong>核心概念</strong></p>
<ol>
<li>**正则表达式（Regex）：**一种用于匹配、查找、替换字符串的「模式语言」，代码中核心模式是<code>p([a-z]+)ch</code>，含义拆解：<ul>
<li><code>p</code>：匹配固定字符 <code>p</code>；</li>
<li><code>([a-z]+)</code>：捕获组（用 <code>()</code> 包裹），匹配 1 个及以上小写字母（<code>[a-z]</code> 是小写字母集合，<code>+</code> 表示匹配 1 次或多次）；</li>
<li><code>ch</code>：匹配固定字符 <code>ch</code>；</li>
<li>整体作用：匹配以 <code>p</code> 开头、<code>ch</code> 结尾，中间是若干小写字母的字符串（如 <code>peach</code>、<code>punch</code>、<code>pinch</code>）。</li>
</ul>
</li>
<li><strong><code>regexp</code> 包核心特点：</strong><ul>
<li>函数分两类：「直接匹配函数」（如 <code>MatchString</code>，无需编译正则）和「编译后方法」（如 <code>Compile</code> 生成 <code>*Regexp</code> 对象，后续可重复调用方法，效率更高）；</li>
<li>字符串 vs 字节切片：大部分函数支持 <code>String</code> 后缀（处理字符串）和无后缀（处理 <code>[]byte</code>），如 <code>MatchString</code>（字符串）、<code>Match</code>（字节切片）；</li>
<li>错误处理：<code>Compile</code> 返回 <code>(*Regexp, error)</code>（需处理解析错误），<code>MustCompile</code> 直接返回 <code>*Regexp</code>（解析失败则 <code>panic</code>，适合硬编码的合法正则）。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;regexp&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 功能：检查字符串是否匹配正则模式，返回 bool（匹配结果）和 error（正则语法错误）</span></span><br><span class="line">    match, _ := regexp.MatchString(<span class="string">&quot;p([a-z]+)ch&quot;</span>, <span class="string">&quot;peach&quot;</span>)</span><br><span class="line">    fmt.Println(match)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能：编译正则模式，返回 *Regexp 对象（可重复调用其方法）和 error（语法错误）</span></span><br><span class="line">    r, _ := regexp.Compile(<span class="string">&quot;p([a-z]+)ch&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 匹配字符串：等价于 MatchString，但复用编译后的对象，效率更高</span></span><br><span class="line">    fmt.Println(r.MatchString(<span class="string">&quot;peach&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 匹配字节切片：支持 []byte 类型输入</span></span><br><span class="line">    fmt.Println(r.FindString(<span class="string">&quot;peach punch&quot;</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;idx:&quot;</span>, r.FindStringIndex(<span class="string">&quot;peach punch&quot;</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.FindStringSubmatch(<span class="string">&quot;peach punch&quot;</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.FindStringSubmatchIndex(<span class="string">&quot;peach punch&quot;</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.FindAllString(<span class="string">&quot;peach punch pinch&quot;</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;all:&quot;</span>, r.FindAllStringSubmatchIndex(</span><br><span class="line">       <span class="string">&quot;peach punch pinch&quot;</span>, <span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.FindAllString(<span class="string">&quot;peach punch pinch&quot;</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">    fmt.Println(r.Match([]<span class="type">byte</span>(<span class="string">&quot;peach&quot;</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能：编译正则，语法错误直接 panic（适合确定正则合法的场景，如硬编码）</span></span><br><span class="line">    r = regexp.MustCompile(<span class="string">&quot;p([a-z]+)ch&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;regexp:&quot;</span>, r) <span class="comment">// 输出：regexp: p([a-z]+)ch（打印正则模式）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能：将所有匹配的子串替换为指定字符串</span></span><br><span class="line">    fmt.Println(r.ReplaceAllString(<span class="string">&quot;a peach&quot;</span>, <span class="string">&quot;&lt;fruit&gt;&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 功能：对每个匹配的子串，调用自定义函数处理后替换</span></span><br><span class="line">    in := []<span class="type">byte</span>(<span class="string">&quot;a peach&quot;</span>)</span><br><span class="line">    out := r.ReplaceAllFunc(in, bytes.ToUpper)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>1.直接匹配：<code>regexp.MatchString</code>（无需编译正则)</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">match, _ := regexp.MatchString(<span class="string">&quot;p([a-z]+)ch&quot;</span>, <span class="string">&quot;peach&quot;</span>)</span><br><span class="line">fmt.Println(match)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>适用场景</strong>：临时单次匹配（无需重复使用正则），简单高效；</li>
<li><strong>参数说明</strong>：第一个参数是正则模式字符串，第二个参数是待匹配字符串；</li>
<li><strong>错误处理</strong>：若正则语法错误（如括号不闭合），第二个返回值 <code>err</code> 非空，示例中省略了错误处理（实际开发需判断）。</li>
</ul>
<p><strong>2. 编译正则：<code>regexp.Compile</code>（重复使用正则，推荐）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">r, _ := regexp.Compile(<span class="string">&quot;p([a-z]+)ch&quot;</span>)</span><br><span class="line"></span><br><span class="line">fmt.Println(r.MatchString(<span class="string">&quot;peach&quot;</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(r.Match([]<span class="type">byte</span>(<span class="string">&quot;peach&quot;</span>))) </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>核心优势</strong>：正则编译是耗时操作，若需多次匹配（如循环中），编译一次后重复使用，性能远高于每次调用 <code>MatchString</code>；</li>
</ul>
<p><strong>3. 查找提取：从字符串中提取匹配内容</strong></p>
<p><code>*Regexp</code> 对象提供了一系列 <code>Find</code> 开头的方法，用于从字符串中查找匹配的内容、位置、子组等，是正则最核心的用法之一：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能描述</th>
<th>示例代码</th>
<th>输出结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>FindString(s string)</code></td>
<td>查找字符串中「第一个完整匹配」的子串</td>
<td><code>r.FindString(&quot;peach punch&quot;)</code></td>
<td><code>peach</code></td>
</tr>
<tr>
<td><code>FindStringIndex(s string)</code></td>
<td>查找第一个完整匹配的「起始和结束索引」（左闭右开）</td>
<td><code>r.FindStringIndex(&quot;peach punch&quot;)</code></td>
<td><code>[0 5]</code></td>
</tr>
<tr>
<td><code>FindStringSubmatch(s string)</code></td>
<td>查找第一个完整匹配，返回「完整匹配 + 所有捕获组匹配」的切片</td>
<td><code>r.FindStringSubmatch(&quot;peach punch&quot;)</code></td>
<td><code>[peach ea]</code></td>
</tr>
<tr>
<td><code>FindStringSubmatchIndex(s string)</code></td>
<td>查找第一个完整匹配，返回「完整匹配 + 捕获组」的索引切片（顺序：完整匹配起止、第一个捕获组起止…）</td>
<td><code>r.FindStringSubmatchIndex(&quot;peach punch&quot;)</code></td>
<td><code>[0 5 1 3]</code></td>
</tr>
<tr>
<td><code>FindAllString(s string, n int)</code></td>
<td>查找「所有完整匹配」的子串，n 控制返回数量（n&#x3D;-1 表示全部，n&#x3D;2 表示前 2 个）</td>
<td><code>r.FindAllString(&quot;peach punch pinch&quot;, -1)</code></td>
<td><code>[peach punch pinch]</code></td>
</tr>
<tr>
<td><code>FindAllStringSubmatchIndex(s string, n int)</code></td>
<td>查找所有匹配的「完整匹配 + 捕获组」索引，n 控制数量</td>
<td><code>r.FindAllStringSubmatchIndex(&quot;peach punch pinch&quot;, -1)</code></td>
<td><code>[[0 5 1 3] [6 11 7 9] [12 17 13 15]]</code></td>
</tr>
</tbody></table>
<p><strong>关键总结</strong>：</p>
<ul>
<li>带 <code>Submatch</code> 的方法会返回捕获组内容 &#x2F; 索引（捕获组是 <code>()</code> 包裹的部分，用于提取子串中的特定片段）；</li>
<li>带 <code>All</code> 的方法会返回所有匹配结果（而非仅第一个）；</li>
<li><code>n</code> 参数：-1 表示返回全部匹配，正数表示返回前 n 个匹配。</li>
</ul>
<p><strong>4. 替换修改：替换字符串中匹配的内容</strong></p>
<p><code>*Regexp</code> 对象提供 <code>Replace</code> 开头的方法，用于替换匹配的子串，支持「固定替换」和「函数自定义替换」：</p>
<p><strong>（1）固定替换：<code>ReplaceAllString</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result := r.ReplaceAllString(<span class="string">&quot;a peach&quot;</span>, <span class="string">&quot;&lt;fruit&gt;&quot;</span>)</span><br><span class="line">fmt.Println(result) <span class="comment">// 输出：a &lt;fruit&gt;（&quot;peach&quot; 被替换为 &quot;&lt;fruit&gt;&quot;）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>带 <code>All</code> 表示替换所有匹配（而非仅第一个）；</li>
<li>若需替换第一个匹配，用 <code>ReplaceString</code>（无 <code>All</code>）。</li>
</ul>
<p><strong>（2）函数自定义替换：<code>ReplaceAllFunc</code></strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in := []<span class="type">byte</span>(<span class="string">&quot;a peach&quot;</span>)</span><br><span class="line">out := r.ReplaceAllFunc(in, bytes.ToUpper)</span><br><span class="line">fmt.Println(<span class="type">string</span>(out)) <span class="comment">// 输出：a PEACH（&quot;peach&quot; 被转为大写）</span></span><br></pre></td></tr></table></figure>

<ul>
<li>参数说明：第一个参数是字节切片（<code>[]byte</code>），第二个参数是函数（输入 <code>[]byte</code>，输出 <code>[]byte</code>）；</li>
<li>适用场景：需要动态处理替换内容（如转大小写、加前缀后缀、根据内容生成替换值）。</li>
</ul>
<p><strong>核心函数 &#x2F; 方法总结</strong></p>
<table>
<thead>
<tr>
<th>函数 &#x2F; 方法名</th>
<th>功能分类</th>
<th>核心作用</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>regexp.MatchString(pat, s)</code></td>
<td>匹配验证</td>
<td>单次匹配字符串，返回是否匹配</td>
<td>临时单次验证（如检查输入格式）</td>
</tr>
<tr>
<td><code>regexp.Compile(pat)</code></td>
<td>正则编译</td>
<td>编译正则，返回可复用的 *Regexp 对象</td>
<td>多次匹配（循环、批量处理）</td>
</tr>
<tr>
<td><code>regexp.MustCompile(pat)</code></td>
<td>正则编译</td>
<td>编译正则，语法错误 panic（简化错误处理）</td>
<td>硬编码的合法正则</td>
</tr>
<tr>
<td><code>r.MatchString(s)</code></td>
<td>匹配验证</td>
<td>复用编译后的正则，匹配字符串</td>
<td>多次匹配场景</td>
</tr>
<tr>
<td><code>r.FindString(s)</code></td>
<td>查找提取</td>
<td>提取第一个完整匹配的子串</td>
<td>提取单个目标子串</td>
</tr>
<tr>
<td><code>r.FindAllString(s, n)</code></td>
<td>查找提取</td>
<td>提取所有 &#x2F;n 个完整匹配的子串</td>
<td>批量提取目标子串</td>
</tr>
<tr>
<td><code>r.FindStringSubmatch(s)</code></td>
<td>查找提取</td>
<td>提取第一个匹配的完整子串 + 捕获组</td>
<td>提取子串中的特定片段（如从 URL 提取域名）</td>
</tr>
<tr>
<td><code>r.ReplaceAllString(s, rep)</code></td>
<td>替换修改</td>
<td>固定替换所有匹配子串</td>
<td>批量替换固定内容（如敏感词替换）</td>
</tr>
<tr>
<td><code>r.ReplaceAllFunc(in, f)</code></td>
<td>替换修改</td>
<td>函数自定义替换所有匹配子串</td>
<td>动态处理替换内容（如转格式）</td>
</tr>
</tbody></table>
<p><code>regexp.Compile</code> 和 <code>regexp.MustCompile</code> 的核心区别是 <strong>错误处理方式不同</strong>，其余功能（编译正则、生成 <code>*Regexp</code> 对象）完全一致 —— 选择哪一个，本质是看是否需要显式处理正则语法错误。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>regexp.Compile</th>
<th>regexp.MustCompile</th>
</tr>
</thead>
<tbody><tr>
<td>函数签名</td>
<td><code>func Compile(expr string) (*Regexp, error)</code></td>
<td><code>func MustCompile(expr string) *Regexp</code></td>
</tr>
<tr>
<td>错误处理方式</td>
<td>返回 <code>error</code>，需手动判断（不 panic）</td>
<td>语法错误直接 <code>panic</code>，无需手动处理错误</td>
</tr>
<tr>
<td>返回值</td>
<td>两个返回值：<code>(*Regexp, error)</code></td>
<td>一个返回值：<code>*Regexp</code></td>
</tr>
<tr>
<td>适用场景</td>
<td>动态正则（如用户输入、配置文件读取的正则）</td>
<td>静态正则（硬编码在代码中，确定语法正确）</td>
</tr>
<tr>
<td>代码简洁度</td>
<td>需写 <code>if err != nil</code> 处理错误，略繁琐</td>
<td>无需错误处理，代码更简洁</td>
</tr>
</tbody></table>
<h2 id="10-JSON"><a href="#10-JSON" class="headerlink" title="10.JSON"></a>10.JSON</h2><p><strong>核心概念</strong></p>
<p><strong>1.JSON 序列化（Marshal）</strong>：将 Go 语言中的数据结构（如 bool、int、切片、字典、结构体）转换为 JSON 格式的字节切片（<code>[]byte</code>），后续可转为字符串或写入文件 &#x2F; 网络；</p>
<p><strong>2.JSON 反序列化（Unmarshal）</strong>：将 JSON 格式的字节切片转换为 Go 语言的数据结构（如字典、结构体），便于程序处理；</p>
<p><strong>3.结构体标签（Struct Tag）</strong>：在结构体字段后添加 <code>json:&quot;key&quot;</code> 标记，控制序列化后的 JSON 字段名（如 <code>Page int &quot;json:page&quot;</code> 序列化后 JSON 字段为 <code>page</code>，而非默认的 <code>Page</code>）；</p>
<p><strong>4.核心函数：</strong></p>
<ul>
<li><code>json.Marshal(v interface&#123;&#125;) ([]byte, error)</code>：序列化，返回 JSON 字节切片和错误；</li>
<li><code>json.Unmarshal(data []byte, v interface&#123;&#125;) error</code>：反序列化，将 JSON 字节解析到目标变量（需传指针）；</li>
<li><code>json.NewEncoder(w io.Writer)</code>：创建 JSON 流式编码器，直接将数据序列化并写入 IO 流（如终端、文件）。</li>
</ul>
<p><strong>5.结构体标签 <code>json:&quot;key&quot;</code> 的作用：</strong></p>
<ul>
<li>控制 JSON 字段名（如统一为小写，适配前端 &#x2F; 第三方接口）；</li>
<li>忽略字段：<code>json:&quot;-&quot;</code>（如 <code>Password string &quot;json:-&quot;</code> 序列化时不包含该字段）；</li>
<li>处理空值：<code>json:&quot;key,omitempty&quot;</code>（字段为空时，序列化时忽略该字段）。</li>
</ul>
<p><strong>6.JSON 类型与 Go 类型映射规则：</strong></p>
<table>
<thead>
<tr>
<th>JSON 类型</th>
<th>Go 类型（反序列化后）</th>
</tr>
</thead>
<tbody><tr>
<td>布尔</td>
<td>bool</td>
</tr>
<tr>
<td>数字</td>
<td>float64（默认，需手动转为 int）</td>
</tr>
<tr>
<td>字符串</td>
<td>string</td>
</tr>
<tr>
<td>数组</td>
<td>[]interface{}</td>
</tr>
<tr>
<td>对象</td>
<td>map[string]interface{}</td>
</tr>
<tr>
<td>null</td>
<td>nil</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体 response1：无 JSON 标签</span></span><br><span class="line"><span class="keyword">type</span> response1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Page   <span class="type">int</span></span><br><span class="line">    Fruits []<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体 response2：带 JSON 标签（控制 JSON 字段名）</span></span><br><span class="line"><span class="keyword">type</span> response2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    Page   <span class="type">int</span>      <span class="string">`json:&quot;page&quot;`</span>   <span class="comment">// 序列化后 JSON 字段为 &quot;page&quot;（小写）</span></span><br><span class="line">    Fruits []<span class="type">string</span> <span class="string">`json:&quot;fruits&quot;`</span> <span class="comment">// 序列化后 JSON 字段为 &quot;fruits&quot;（小写）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 布尔值 → JSON 布尔</span></span><br><span class="line">    bolB, _ := json.Marshal(<span class="literal">true</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(bolB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 整数 → JSON 数字</span></span><br><span class="line">    intB, _ := json.Marshal(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(intB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 浮点数 → JSON 数字</span></span><br><span class="line">    fltB, _ := json.Marshal(<span class="number">2.34</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(fltB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 字符串 → JSON 字符串（自动添加双引号）</span></span><br><span class="line">    strB, _ := json.Marshal(<span class="string">&quot;gopher&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(strB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 切片 → JSON 数组</span></span><br><span class="line">    slcD := []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;</span><br><span class="line">    slcB, _ := json.Marshal(slcD)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(slcB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 字典 → JSON 对象（键为字符串，值为任意类型）</span></span><br><span class="line">    mapD := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">    mapB, _ := json.Marshal(mapD)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(mapB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化 response1（无标签）</span></span><br><span class="line">    res1D := &amp;response1&#123;</span><br><span class="line">       Page:   <span class="number">1</span>,</span><br><span class="line">       Fruits: []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;&#125;</span><br><span class="line">    res1B, _ := json.Marshal(res1D)</span><br><span class="line">    <span class="comment">// 输出：&#123;&quot;Page&quot;:1,&quot;Fruits&quot;:[&quot;apple&quot;,&quot;peach&quot;,&quot;pear&quot;]&#125;（字段名与结构体一致）</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(res1B))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化 response2（带标签）</span></span><br><span class="line">    res2D := &amp;response2&#123;</span><br><span class="line">       Page:   <span class="number">1</span>,</span><br><span class="line">       Fruits: []<span class="type">string</span>&#123;<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;peach&quot;</span>, <span class="string">&quot;pear&quot;</span>&#125;&#125;</span><br><span class="line">    res2B, _ := json.Marshal(res2D)</span><br><span class="line">    <span class="comment">// 输出：&#123;&quot;page&quot;:1,&quot;fruits&quot;:[&quot;apple&quot;,&quot;peach&quot;,&quot;pear&quot;]&#125;（字段名按标签定义）</span></span><br><span class="line">    fmt.Println(<span class="type">string</span>(res2B))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 字节切片（模拟从文件/网络接收的 JSON 数据）</span></span><br><span class="line">    byt := []<span class="type">byte</span>(<span class="string">`&#123;&quot;num&quot;:6.13,&quot;strs&quot;:[&quot;a&quot;,&quot;b&quot;]&#125;`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义目标变量：map[string]interface&#123;&#125;（动态类型）</span></span><br><span class="line">    <span class="keyword">var</span> dat <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化：将 JSON 字节解析到 dat（需传指针）</span></span><br><span class="line">    <span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：map[num:6.13 strs:[a b]]（dat 是字典，值类型自动推断）</span></span><br><span class="line">    fmt.Println(dat)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型断言：将 interface&#123;&#125; 转为具体类型（JSON 数字默认转为 float64，数组转为 []interface&#123;&#125;）</span></span><br><span class="line">    num := dat[<span class="string">&quot;num&quot;</span>].(<span class="type">float64</span>)</span><br><span class="line">    fmt.Println(num)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 数组 → Go []interface&#123;&#125;</span></span><br><span class="line">    strs := dat[<span class="string">&quot;strs&quot;</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    str1 := strs[<span class="number">0</span>].(<span class="type">string</span>)</span><br><span class="line">    fmt.Println(str1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// JSON 字符串（模拟输入）</span></span><br><span class="line">    str := <span class="string">`&#123;&quot;page&quot;: 1, &quot;fruits&quot;: [&quot;apple&quot;, &quot;peach&quot;]&#125;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义目标结构体（字段名与 JSON 字段名一致，或通过标签映射）</span></span><br><span class="line">    res := response2&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化：将 JSON 字符串转为字节切片，解析到 res（需传指针）</span></span><br><span class="line">    json.Unmarshal([]<span class="type">byte</span>(str), &amp;res)</span><br><span class="line">    fmt.Println(res)</span><br><span class="line">    fmt.Println(res.Fruits[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 JSON 编码器，写入目标 IO 流（这里是 os.Stdout 标准输出，即终端）</span></span><br><span class="line">    enc := json.NewEncoder(os.Stdout)</span><br><span class="line">    d := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;lettuce&quot;</span>: <span class="number">7</span>&#125;</span><br><span class="line">    <span class="comment">// 编码并写入：自动序列化数据为 JSON，输出到终端</span></span><br><span class="line">    enc.Encode(d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心注意点</strong></p>
<p>**1.结构体字段必须导出：**首字母必须大写，否则<code>json</code>包无法访问，序列化 &#x2F; 反序列化时会忽略该字段；</p>
<ul>
<li>错误示例：<code>type User struct &#123; name string &#125;</code> → 序列化后 JSON 为空（<code>&#123;&#125;</code>）；</li>
<li>正确示例：<code>type User struct &#123; Name string &#125;</code> → 序列化后 <code>&#123;&quot;Name&quot;:&quot;xxx&quot;&#125;</code>。</li>
</ul>
<p><strong>2.JSON 数字默认转为 float64</strong>：反序列化为字典时，JSON 中的所有数字（整数、浮点数）都会转为 Go 的 <code>float64</code>，需手动转为 <code>int</code>（如 <code>int(num.(float64))</code>）；</p>
<ul>
<li>避免坑：若 JSON 字段是整数，反序列化为结构体时直接定义为 <code>int</code> 类型（如 <code>Page int</code>），无需手动转换。</li>
</ul>
<p><strong>3.空值处理：</strong></p>
<ul>
<li>序列化时，结构体的零值字段（如 <code>int(0)</code>、<code>string(&quot;&quot;)</code>、<code>nil</code> 切片）会默认包含在 JSON 中；</li>
<li>若需忽略零值字段，添加标签 <code>json:&quot;key,omitempty&quot;</code>（如 <code>Age int &quot;json:age,omitempty&quot;</code>，Age&#x3D;0 时不序列化）。</li>
</ul>
<p><strong>4.错误处理</strong>：示例中省略了错误处理（<code>_</code> 忽略错误），实际开发中必须处理 <code>Marshal</code>&#x2F;<code>Unmarshal</code> 的返回错误（如 JSON 语法错误、类型不匹配）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确示例：处理反序列化错误</span></span><br><span class="line"><span class="keyword">if</span> err := json.Unmarshal(byt, &amp;dat); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;反序列化失败：%v\n&quot;</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h2><p><strong>核心概念</strong></p>
<ol>
<li><strong>XML 序列化（Marshal）</strong>：将 Go 结构体转换为 XML 格式的字节切片（<code>[]byte</code>），支持格式化输出（缩进、换行）；</li>
<li><strong>XML 反序列化（Unmarshal）</strong>：将 XML 字节切片转换为 Go 结构体，通过「结构体标签」映射 XML 元素 &#x2F; 属性；</li>
<li><strong>XML 结构体标签</strong>：Go 结构体字段后添加 <code>xml:&quot;key,option&quot;</code> 标记，用于控制 XML 生成规则（如元素名、属性、嵌套路径），是 XML 处理的核心；</li>
<li><strong>核心函数：</strong><ul>
<li><code>xml.Marshal(v interface&#123;&#125;) ([]byte, error)</code>：序列化，返回紧凑格式的 XML 字节（无缩进）；</li>
<li><code>xml.MarshalIndent(v interface&#123;&#125;, prefix, indent string)</code>：序列化，返回带缩进的格式化 XML（<code>prefix</code> 是每行前缀，<code>indent</code> 是缩进字符，如空格、制表符）；</li>
<li><code>xml.Unmarshal(data []byte, v interface&#123;&#125;) error</code>：反序列化，将 XML 字节解析到目标结构体（需传指针）；</li>
<li><code>xml.Header</code>：内置常量，包含 XML 声明（<code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code>），可直接拼接在 XML 字节前。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/xml&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Plant 结构体：映射 XML 元素 &lt;plant&gt;</span></span><br><span class="line"><span class="keyword">type</span> Plant <span class="keyword">struct</span> &#123;</span><br><span class="line">    XMLName xml.Name <span class="string">`xml:&quot;plant&quot;`</span>   <span class="comment">// 指定 XML 根元素名（必须是 xml.Name 类型）</span></span><br><span class="line">    Id      <span class="type">int</span>      <span class="string">`xml:&quot;id,attr&quot;`</span> <span class="comment">// 映射 XML 属性 id（格式：xml:&quot;属性名,attr&quot;）</span></span><br><span class="line">    Name    <span class="type">string</span>   <span class="string">`xml:&quot;name&quot;`</span>    <span class="comment">// 映射 XML 子元素 &lt;name&gt;</span></span><br><span class="line">    Origin  []<span class="type">string</span> <span class="string">`xml:&quot;origin&quot;`</span>  <span class="comment">// 映射多个 XML 子元素 &lt;origin&gt;（切片对应重复元素）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Plant)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Plant id=%v, name=%v, origin=%v&quot;</span>,</span><br><span class="line">       p.Id, p.Name, p.Origin)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 Plant 实例</span></span><br><span class="line">    coffee := &amp;Plant&#123;Id: <span class="number">27</span>, Name: <span class="string">&quot;Coffee&quot;</span>&#125;</span><br><span class="line">    coffee.Origin = []<span class="type">string</span>&#123;<span class="string">&quot;Ethiopia&quot;</span>, <span class="string">&quot;Brazil&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 带缩进的序列化（推荐，XML 更易读）</span></span><br><span class="line">    <span class="comment">// 参数：目标结构体、每行前缀（&quot;&quot; 空）、缩进字符（&quot;  &quot; 两个空格）</span></span><br><span class="line">    out, _ := xml.MarshalIndent(coffee, <span class="string">&quot; &quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(out))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 拼接 XML 声明（xml.Header）</span></span><br><span class="line">    <span class="comment">// xml.Header 是内置常量：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">    fmt.Println(xml.Header + <span class="type">string</span>(out))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义目标结构体变量（空实例）</span></span><br><span class="line">    <span class="keyword">var</span> p Plant</span><br><span class="line">    <span class="comment">// 反序列化：将 XML 字节（out）解析到 p（需传指针 &amp;p）</span></span><br><span class="line">    <span class="keyword">if</span> err := xml.Unmarshal(out, &amp;p); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(p) <span class="comment">// 打印结构体（调用自定义的 String() 方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 创建另一个 Plant 实例（Tomato）</span></span><br><span class="line">    tomato := &amp;Plant&#123;Id: <span class="number">81</span>, Name: <span class="string">&quot;Tomato&quot;</span>&#125;</span><br><span class="line">    tomato.Origin = []<span class="type">string</span>&#123;<span class="string">&quot;Mexico&quot;</span>, <span class="string">&quot;California&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 定义嵌套结构体 Nesting：映射多层 XML 结构</span></span><br><span class="line">    <span class="keyword">type</span> Nesting <span class="keyword">struct</span> &#123;</span><br><span class="line">       XMLName xml.Name <span class="string">`xml:&quot;nesting&quot;`</span></span><br><span class="line">       <span class="comment">// 关键：Plants 字段映射到 XML 路径 parent&gt;child&gt;plant（多层嵌套）</span></span><br><span class="line">       Plants []*Plant <span class="string">`xml:&quot;parent&gt;child&gt;plant&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建嵌套结构体实例</span></span><br><span class="line">    nesting := &amp;Nesting&#123;&#125;</span><br><span class="line">    nesting.Plants = []*Plant&#123;coffee, tomato&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 序列化嵌套结构体（带缩进）</span></span><br><span class="line">    out, _ = xml.MarshalIndent(nesting, <span class="string">&quot; &quot;</span>, <span class="string">&quot;  &quot;</span>)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(out))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心 XML 标签大全</strong></p>
<p>除了代码中用到的标签，补充常用 XML 标签规则，覆盖更多场景：</p>
<table>
<thead>
<tr>
<th>结构体字段定义</th>
<th>XML 标签格式</th>
<th>序列化后效果</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>Field string</code></td>
<td>无标签</td>
<td><code>&lt;Field&gt;value&lt;/Field&gt;</code></td>
<td>默认映射（元素名 &#x3D; 字段名）</td>
</tr>
<tr>
<td><code>Field string </code>xml:”elem”&#96;</td>
<td><code>xml:&quot;elem&quot;</code></td>
<td><code>&lt;elem&gt;value&lt;/elem&gt;</code></td>
<td>自定义 XML 元素名</td>
</tr>
<tr>
<td><code>Field int </code>xml:”id,attr”&#96;</td>
<td><code>xml:&quot;name,attr&quot;</code></td>
<td><code>&lt;root id=&quot;value&quot;&gt;</code></td>
<td>映射为 XML 属性</td>
</tr>
<tr>
<td><code>Field []string </code>xml:”tag”&#96;</td>
<td><code>xml:&quot;tag&quot;</code></td>
<td><code>&lt;tag&gt;v1&lt;/tag&gt;&lt;tag&gt;v2&lt;/tag&gt;</code></td>
<td>切片映射为多个同名元素</td>
</tr>
<tr>
<td><code>Field string </code>xml:”,chardata”&#96;</td>
<td><code>xml:&quot;,chardata&quot;</code></td>
<td><code>&lt;root&gt;value&lt;/root&gt;</code>（无子元素，直接文本）</td>
<td>字段映射为元素的文本内容（而非子元素 &#x2F; 属性）</td>
</tr>
<tr>
<td><code>Field string </code>xml:”,innerxml”&#96;</td>
<td><code>xml:&quot;,innerxml&quot;</code></td>
<td><code>&lt;root&gt;&lt;a&gt;v&lt;/a&gt;&lt;/root&gt;</code>（直接嵌入 XML 片段）</td>
<td>字段值为原始 XML 片段，序列化时直接嵌入</td>
</tr>
<tr>
<td><code>Field string </code>xml:”-“&#96;</td>
<td><code>xml:&quot;-&quot;</code></td>
<td>无对应 XML 元素 &#x2F; 属性</td>
<td>忽略该字段（不序列化也不反序列化）</td>
</tr>
<tr>
<td><code>Field []*Plant </code>xml:”a&gt;b&gt;c”&#96;</td>
<td><code>xml:&quot;a&gt;b&gt;c&quot;</code></td>
<td><code>&lt;a&gt;&lt;b&gt;&lt;c&gt;...&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</code></td>
<td>映射多层嵌套路径</td>
</tr>
</tbody></table>
<p><strong>关键注意点</strong></p>
<ol>
<li>**结构体字段必须导出：**首字母大写，否则<code>xml</code>包无法访问，序列化 &#x2F; 反序列化时忽略该字段；<ul>
<li>错误示例：<code>type Plant struct &#123; id int &#125;</code> → 序列化后无 <code>id</code> 属性；</li>
<li>正确示例：<code>type Plant struct &#123; Id int &quot;xml:id,attr&quot; &#125;</code> → 正常生成 <code>id</code> 属性。</li>
</ul>
</li>
<li><strong>属性标签必须带 <code>,attr</code></strong>：若写成 <code>xml:&quot;id&quot;</code>（无 <code>,attr</code>），会生成子元素 <code>&lt;id&gt;</code> 而非属性 <code>id</code>；</li>
<li><strong>切片对应重复元素</strong>：只有切片字段（<code>[]T</code>）才能映射 XML 中的重复元素（如多个 <code>&lt;origin&gt;</code>），非切片字段会只取最后一个匹配元素；</li>
<li><strong>嵌套路径标签的限制</strong>：<code>xml:&quot;a&gt;b&gt;c&quot;</code> 中的路径必须是「直接父子关系」，且只能用于子元素（不能用于属性）；</li>
<li><strong>编码问题</strong>：<code>xml.Header</code> 默认编码是 <code>UTF-8</code>，若需其他编码（如 <code>GBK</code>），需手动修改声明（如 <code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;</code>）；</li>
<li><strong>错误处理</strong>：示例中省略了错误处理（<code>_</code> 忽略错误），实际开发中必须处理 <code>Marshal</code>&#x2F;<code>Unmarshal</code> 的返回错误（如 XML 语法错误、类型不匹配）。</li>
</ol>
<h2 id="12-时间"><a href="#12-时间" class="headerlink" title="12.时间"></a>12.时间</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	p := fmt.Println</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 功能：获取当前「本地时间」（包含时区、纳秒精度），返回 time.Time 类型</span></span><br><span class="line">	now := time.Now()</span><br><span class="line">	p(now) <span class="comment">// 输出格式：年-月-日 时:分:秒.纳秒 时区 额外信息（m=+... 是相对于程序启动的时间）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 功能：构造指定日期时间的 time.Time 实例，参数顺序：年、月、日、时、分、秒、纳秒、时区</span></span><br><span class="line">	then := time.Date(</span><br><span class="line">		<span class="number">2009</span>, <span class="number">11</span>, <span class="number">17</span>, <span class="number">20</span>, <span class="number">34</span>, <span class="number">58</span>, <span class="number">651387237</span>, time.UTC)</span><br><span class="line">	p(then)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从 time.Time 实例中提取年、月、日、时、分、秒、纳秒、时区、星期等字段：</span></span><br><span class="line">	p(then.Year())</span><br><span class="line">	p(then.Month())</span><br><span class="line">	p(then.Day())</span><br><span class="line">	p(then.Hour())</span><br><span class="line">	p(then.Minute())</span><br><span class="line">	p(then.Second())</span><br><span class="line">	p(then.Nanosecond())</span><br><span class="line">	p(then.Location())</span><br><span class="line">	p(then.Weekday())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 时间比较：Before()/After()/Equal()</span></span><br><span class="line">	p(then.Before(now)) <span class="comment">// bool：then 是否在 now 之前？（示例输出 true）</span></span><br><span class="line">	p(then.After(now))  <span class="comment">// bool：then 是否在 now 之后？（示例输出 false）</span></span><br><span class="line">	p(then.Equal(now))  <span class="comment">// bool：then 与 now 是否完全相等？（需时间戳、时区都一致，示例输出 false）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 时间差计算：Sub() 与 time.Duration</span></span><br><span class="line">	<span class="comment">// 用 t.Sub(u) 计算 t - u 的时间差，返回 time.Duration 类型（表示时间段），支持换算为小时、分钟、秒、纳秒：</span></span><br><span class="line">	diff := now.Sub(then) <span class="comment">// 计算 now - then 的时间差（time.Duration 类型）</span></span><br><span class="line">	p(diff)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 时间差换算为不同单位（返回 float64 类型）</span></span><br><span class="line">	p(diff.Hours())</span><br><span class="line">	p(diff.Minutes())</span><br><span class="line">	p(diff.Seconds())</span><br><span class="line">	p(diff.Nanoseconds())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 时间增减：Add()</span></span><br><span class="line">	<span class="comment">// 在 time.Time 实例基础上增减指定时间段（time.Duration 类型），返回新的 time.Time 实例（原实例不变，因为 time.Time 是不可变类型）</span></span><br><span class="line">	p(then.Add(diff))  <span class="comment">// then + diff = now（示例输出与 now 一致，时区自动适配）</span></span><br><span class="line">	p(then.Add(-diff)) <span class="comment">// then - diff = 更早的时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键注意点</strong></p>
<ol>
<li><p><strong><code>time.Time</code> 是不可变类型</strong>：</p>
<ul>
<li>所有修改时间的方法（<code>Add()</code>、<code>UTC()</code>、<code>Local()</code> 等）都会返回新的 <code>time.Time</code> 实例，原实例不会改变；</li>
<li>错误示例：<code>now.Add(1*time.Hour)</code> → 不会修改 <code>now</code>，需赋值给新变量：<code>later := now.Add(1*time.Hour)</code>。</li>
</ul>
</li>
<li><p><strong>时区处理是核心坑点</strong>：</p>
<ul>
<li>不同时区的时间比较会自动转换（<code>Before()</code>&#x2F;<code>After()</code> 无需手动处理）；</li>
<li>构造时间时必须指定时区（否则默认 <code>time.UTC</code>），避免时区混淆（如北京时间 12 点 vs UTC 12 点）；</li>
<li>本地时区 <code>time.Local</code> 依赖系统环境，跨平台 &#x2F; 跨服务器可能不一致，推荐用 <code>time.UTC</code> 或显式指定时区（如 <code>time.FixedZone(&quot;CST&quot;, 8*3600)</code> 表示 UTC+8）。</li>
</ul>
</li>
<li><p><strong>字符串与时间互转的格式符</strong>（补充高频用法）：</p>
<ul>
<li>Go 的时间格式符是「固定参考时间 <code>2006-01-02 15:04:05</code>」（不是 <code>YYYY-MM-DD</code>），必须严格对应</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串转时间</span></span><br><span class="line">str := <span class="string">&quot;2025-11-13 15:30:00&quot;</span></span><br><span class="line">t, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, str) <span class="comment">// 格式符必须与字符串格式一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间转字符串</span></span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;2006-01-02&quot;</span>)) <span class="comment">// 输出：2025-11-13</span></span><br><span class="line">fmt.Println(t.Format(<span class="string">&quot;15:04:05&quot;</span>))   <span class="comment">// 输出：15:30:00</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="13-时间戳"><a href="#13-时间戳" class="headerlink" title="13.时间戳"></a>13.时间戳</h2><p><strong>核心概念</strong></p>
<ol>
<li><strong>时间戳（Timestamp）</strong>：从「Unix 纪元（1970-01-01 00:00:00 UTC）」到目标时间的「累计时长」，是衡量时间的标准化方式（跨语言 &#x2F; 跨平台通用）；</li>
<li><strong>Go 中时间戳的三种精度（核心区别在单位）：</strong><ul>
<li>秒级时间戳（<code>Unix</code>）：单位是「秒」，忽略毫秒、微秒、纳秒，精度最低；</li>
<li>毫秒级时间戳：单位是「毫秒」（1 秒 &#x3D; 1000 毫秒），需通过纳秒级换算得到；</li>
<li>纳秒级时间戳（<code>UnixNano</code>）：单位是「纳秒」（1 秒 &#x3D; 1e9 纳秒），<code>time</code> 包原生支持，精度最高；</li>
</ul>
</li>
<li><strong>核心函数：</strong><ul>
<li><code>t.Unix()</code>：从 <code>time.Time</code> 实例获取「秒级时间戳」（返回 <code>int64</code> 类型）；</li>
<li><code>t.UnixNano()</code>：从 <code>time.Time</code> 实例获取「纳秒级时间戳」（返回 <code>int64</code> 类型）；</li>
<li><code>time.Unix(sec int64, nsec int64)</code>：从「秒级时间戳 + 纳秒偏移」构造 <code>time.Time</code> 实例（<code>nsec</code> 范围 0-999999999）。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前本地时间（time.Time 类型，包含完整时间信息）</span></span><br><span class="line">    now := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取「秒级时间戳」：Unix 纪元到 now 的总秒数（忽略毫秒/纳秒）</span></span><br><span class="line">    secs := now.Unix()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  获取「纳秒级时间戳」：Unix 纪元到 now 的总纳秒数（完整精度）</span></span><br><span class="line">    nanos := now.UnixNano()</span><br><span class="line">    fmt.Println(now)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 毫秒级时间戳 = 纳秒级时间戳 / 1e6（1 毫秒 = 1000000 纳秒）</span></span><br><span class="line">    millis := nanos / <span class="number">1000000</span></span><br><span class="line">    fmt.Println(secs)</span><br><span class="line">    fmt.Println(millis)</span><br><span class="line">    fmt.Println(nanos)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从「秒级时间戳」构造时间：第二个参数是「纳秒偏移」（0 表示无偏移）</span></span><br><span class="line">    <span class="comment">// 效果：仅保留秒级精度，毫秒/纳秒部分为 0</span></span><br><span class="line">    fmt.Println(time.Unix(secs, <span class="number">0</span>))</span><br><span class="line">    fmt.Println(time.Unix(<span class="number">0</span>, nanos))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-时间的格式化和解析"><a href="#14-时间的格式化和解析" class="headerlink" title="14.时间的格式化和解析"></a>14.时间的格式化和解析</h2><p><strong>核心规则</strong></p>
<p>Go 的时间格式化 &#x2F; 解析和其他语言（如 Java 的 <code>yyyy-MM-dd</code>）完全不同，<strong>核心规则是：用「固定参考时间」的格式作为模板，而非占位符</strong>。</p>
<ul>
<li>固定参考时间：<code>Mon Jan 2 15:04:05 MST 2006</code>（记忆口诀：<strong>1 月 2 日 3 点 4 分 5 秒 6 年</strong>，对应 <code>1 2 3 4 5 6</code>，再加上时区 <code>MST</code>）；</li>
<li>格式化（<code>t.Format(layout)</code>）：将 <code>time.Time</code> 实例按 <code>layout</code>（参考时间的格式模板）转为字符串；</li>
<li>解析（<code>time.Parse(layout, str)</code>）：将字符串 <code>str</code> 按 <code>layout</code> 模板解析为 <code>time.Time</code> 实例；</li>
<li>关键：<code>layout</code> 必须和目标字符串的「格式完全对应」（包括空格、标点、大小写、数字位数），否则格式化 &#x2F; 解析会出错或返回错误。</li>
</ul>
<p>常用预定义格式补充：</p>
<table>
<thead>
<tr>
<th>预定义常量</th>
<th>格式模板</th>
<th>输出示例</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><code>time.RFC3339</code></td>
<td><code>2006-01-02T15:04:05Z07:00</code></td>
<td><code>2025-11-13T17:20:30+08:00</code></td>
<td>接口、日志（跨系统兼容）</td>
</tr>
<tr>
<td><code>time.RFC1123</code></td>
<td><code>Mon, 02 Jan 2006 15:04:05 MST</code></td>
<td><code>Thu, 13 Nov 2025 17:20:30 CST</code></td>
<td>HTTP 头部时间格式</td>
</tr>
<tr>
<td><code>time.ANSIC</code></td>
<td><code>Mon Jan _2 15:04:05 2006</code></td>
<td><code>Thu Nov 13 17:20:30 2025</code></td>
<td>通用日志格式</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := fmt.Println</span><br><span class="line"></span><br><span class="line">    t := time.Now()</span><br><span class="line">    <span class="comment">// 预定义格式 RFC3339（国际标准格式，含时区，常用于接口/日志）</span></span><br><span class="line">    p(t.Format(time.RFC3339))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 RFC3339 格式的字符串（格式必须完全匹配）</span></span><br><span class="line">    t1, e := time.Parse(</span><br><span class="line">       time.RFC3339,</span><br><span class="line">       <span class="string">&quot;2012-11-01T22:08:41+00:00&quot;</span>)</span><br><span class="line">    p(t1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 12小时制（3=15点→下午3点，PM 区分上/下午）</span></span><br><span class="line">    p(t.Format(<span class="string">&quot;3:04PM&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完整自定义格式（星期 月 日 时:分:秒 年）</span></span><br><span class="line">    <span class="comment">//  _2：日期占2位，不足补空格（如1号→&quot; 1&quot;）；若用02→不足补0（如1号→&quot;01&quot;）</span></span><br><span class="line">    p(t.Format(<span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span>))</span><br><span class="line">    <span class="comment">// 带微秒和时区的格式（.999999 表示6位微秒，-07:00 表示时区偏移）</span></span><br><span class="line">    p(t.Format(<span class="string">&quot;2006-01-02T15:04:05.999999-07:00&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式模板：12小时制（3=12小时制小时，04=分钟，PM=上/下午）</span></span><br><span class="line">    form := <span class="string">&quot;3 04 PM&quot;</span></span><br><span class="line">    t2, e := time.Parse(form, <span class="string">&quot;8 41 PM&quot;</span>)</span><br><span class="line">    p(t2)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d-%02d-%02dT%02d:%02d:%02d-00:00\n&quot;</span>,</span><br><span class="line">       t.Year(), t.Month(), t.Day(),</span><br><span class="line">       t.Hour(), t.Minute(), t.Second())</span><br><span class="line"></span><br><span class="line">    ansic := <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">    _, e = time.Parse(ansic, <span class="string">&quot;8:41PM&quot;</span>)</span><br><span class="line">    p(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心函数 &#x2F; 用法总结</strong></p>
<table>
<thead>
<tr>
<th>操作需求</th>
<th>函数 &#x2F; 代码示例</th>
<th>关键说明</th>
</tr>
</thead>
<tbody><tr>
<td>时间→字符串（预定义格式）</td>
<td><code>t.Format(time.RFC3339)</code></td>
<td>推荐，跨系统兼容，无需记忆模板</td>
</tr>
<tr>
<td>时间→字符串（自定义格式）</td>
<td><code>t.Format(&quot;2006-01-02 15:04:05&quot;)</code>（24 小时制）、<code>t.Format(&quot;2006-01-02 3:04PM&quot;)</code>（12 小时制）</td>
<td>严格遵循参考时间模板 <code>2006-01-02 15:04:05</code></td>
</tr>
<tr>
<td>字符串→时间（预定义格式）</td>
<td><code>time.Parse(time.RFC3339, &quot;2025-11-13T17:20:30+08:00&quot;)</code></td>
<td>字符串格式必须和预定义格式完全一致</td>
</tr>
<tr>
<td>字符串→时间（自定义格式）</td>
<td><code>time.Parse(&quot;2006-01-02 15:04:05&quot;, &quot;2025-11-13 17:20:30&quot;)</code></td>
<td>模板和字符串的空格、标点、位数必须匹配</td>
</tr>
<tr>
<td>手动格式化（简单场景）</td>
<td><code>fmt.Printf(&quot;%04d-%02d-%02d&quot;, t.Year(), t.Month(), t.Day())</code></td>
<td>需手动补零，灵活度低</td>
</tr>
</tbody></table>
<p><strong>关键注意点</strong></p>
<ol>
<li><strong>模板是 “参考时间” 而非占位符</strong>：<ul>
<li>错误示例：用 <code>yyyy-MM-dd</code> 作为模板（其他语言的占位符）→ 解析 &#x2F; 格式化完全失败；</li>
<li>正确示例：必须用 <code>2006-01-02</code> 表示「年 - 月 - 日」，<code>15:04:05</code> 表示「时：分: 秒」。</li>
</ul>
</li>
<li><strong>格式匹配必须 “严丝合缝”</strong>：<ul>
<li>空格、标点、大小写都要一致（如模板是 <code>3:04 PM</code>，字符串不能是 <code>3:41PM</code>（少空格）或 <code>3:41 pm</code>（小写 pm））；</li>
<li>数字位数一致（如模板是 <code>04</code>（2 位分钟），字符串不能是 <code>4</code>（1 位分钟），需补零为 <code>04</code>）。</li>
</ul>
</li>
<li><strong>解析时的 “零时间” 填充</strong>：<ul>
<li>若字符串中缺失年、月、日、时等字段，解析后会填充默认值（年 &#x3D; 0000，月 &#x3D; 01，日 &#x3D; 01，时 &#x3D; 00 等）；</li>
<li>若需避免零时间，需确保字符串包含完整字段，或解析后手动修正（如 <code>t2 = t2.AddDate(2025, 0, 0)</code> 补全年份）。</li>
</ul>
</li>
<li><strong>时区处理</strong>：<ul>
<li>格式化时，<code>Format</code> 会默认使用 <code>time.Time</code> 实例的时区（如 <code>time.Now()</code> 是本地时区）；</li>
<li>解析时，若字符串不含时区（如 <code>2025-11-13 17:20:30</code>），解析后的 <code>time.Time</code> 时区为 <code>UTC</code>（默认），需手动转换为本地时区：<code>t.Local()</code>。</li>
</ul>
</li>
<li><strong>错误处理不能少</strong>：<ul>
<li>解析用户输入、接口返回的时间字符串时，必须处理 <code>Parse</code> 的返回错误（如格式错误、非法日期），避免程序 panic；</li>
</ul>
</li>
</ol>
<h2 id="15-随机数"><a href="#15-随机数" class="headerlink" title="15.随机数"></a>15.随机数</h2><p><strong>核心概念</strong></p>
<ol>
<li><strong>伪随机数</strong>：<code>math/rand</code> 生成的是「伪随机数」—— 基于一个初始值（称为「种子（Seed）」），通过固定算法计算得出的序列。相同种子会生成完全相同的随机数序列（可复现）；</li>
<li><strong>种子</strong>：随机数生成的「初始密钥」，默认种子是 <code>1</code>（固定值），所以默认生成的随机数序列是固定的；</li>
<li><strong>核心组件：</strong><ul>
<li><code>rand.Source</code>：随机数「源」，封装了种子和随机数生成算法（是 <code>rand.Rand</code> 的底层依赖）；</li>
<li><code>rand.Rand</code>：随机数生成器实例，通过 <code>rand.New(source)</code> 创建，可重复调用方法生成随机数（线程安全）；</li>
</ul>
</li>
<li><strong>核心函数 &#x2F; 方法：</strong><ul>
<li><code>rand.Intn(n int)</code>：生成 <code>[0, n)</code> 区间的整数随机数（n 必须大于 0）；</li>
<li><code>rand.Float64()</code>：生成 <code>[0.0, 1.0)</code> 区间的浮点数随机数；</li>
<li><code>rand.NewSource(seed int64)</code>：创建随机数源（传入 64 位种子）；</li>
<li><code>rand.New(source Source)</code>：创建随机数生成器实例（基于源）。</li>
</ul>
</li>
</ol>
<p><strong>动态种子保随机，固定种子保复现，安全场景用 crypto&#x2F;rand</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math/rand&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 生成 [0, 100) 区间的整数随机数（2个）</span></span><br><span class="line">    <span class="comment">// 默认种子是 1（固定值），所以每次运行程序都会生成「完全相同的随机数序列」</span></span><br><span class="line">    <span class="comment">// 这不是真正的随机，仅适合测试场景，不适合生产环境；</span></span><br><span class="line">    fmt.Print(rand.Intn(<span class="number">100</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    fmt.Print(rand.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 [0.0, 1.0) 区间的浮点数随机数</span></span><br><span class="line">    fmt.Println(rand.Float64())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 [5.0, 10.0) 区间的浮点数随机数（公式：min + rand.Float64()*(max-min)）</span></span><br><span class="line">    fmt.Print((rand.Float64()*<span class="number">5</span>)+<span class="number">5</span>, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    fmt.Print((rand.Float64() * <span class="number">5</span>) + <span class="number">5</span>)</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态种子：基于当前时间戳生成（生产环境推荐）</span></span><br><span class="line">    <span class="comment">// 创建动态种子：用当前时间的纳秒级时间戳（time.Now().UnixNano()）作为种子（每次运行都不同）</span></span><br><span class="line">    s1 := rand.NewSource(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于种子创建随机数生成器实例（r1）</span></span><br><span class="line">    r1 := rand.New(s1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用生成器生成 [0, 100) 区间的整数随机数</span></span><br><span class="line">    fmt.Print(r1.Intn(<span class="number">100</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    fmt.Print(r1.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定种子：生成可复现的随机数</span></span><br><span class="line">    s2 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">    r2 := rand.New(s2)</span><br><span class="line">    fmt.Print(r2.Intn(<span class="number">100</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    fmt.Print(r2.Intn(<span class="number">100</span>))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次创建相同固定种子（42）的随机数源</span></span><br><span class="line">    s3 := rand.NewSource(<span class="number">42</span>)</span><br><span class="line">    r3 := rand.New(s3)</span><br><span class="line">    fmt.Print(r3.Intn(<span class="number">100</span>), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    fmt.Print(r3.Intn(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-数字解析"><a href="#16-数字解析" class="headerlink" title="16.数字解析"></a>16.数字解析</h2><p><code>strconv</code> 包提供了一套完整的字符串转数字的方法，支持不同类型（浮点数 &#x2F; 整数 &#x2F; 无符号整数）、不同进制（十进制 &#x2F; 十六进制），并通过返回错误提示解析失败原因。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
<th>适用场景</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td><code>ParseFloat</code></td>
<td>字符串 → 浮点数</td>
<td>解析小数（如 <code>&quot;1.23&quot;</code>、<code>&quot;-4.5&quot;</code>）</td>
<td>需指定精度（32&#x2F;64）</td>
</tr>
<tr>
<td><code>ParseInt</code></td>
<td>字符串 → 有符号整数</td>
<td>解析多进制整数（十进制 &#x2F; 十六进制）</td>
<td>支持进制自动识别，需指定位宽</td>
</tr>
<tr>
<td><code>ParseUint</code></td>
<td>字符串 → 无符号整数</td>
<td>解析无符号多进制整数</td>
<td>与 <code>ParseInt</code> 功能类似，返回无符号整数</td>
</tr>
<tr>
<td><code>Atoi</code></td>
<td>字符串 → 十进制 int 整数</td>
<td>简单十进制整数解析（最常用）</td>
<td>简化用法，无需额外参数，默认十进制</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    字符串转浮点数：strconv.ParseFloat</span></span><br><span class="line"><span class="comment">       第一个参数：待解析的字符串（必须是合法的浮点数格式，如 &quot;1.23&quot;、&quot;-4.56&quot;）；</span></span><br><span class="line"><span class="comment">       第二个参数：指定浮点数精度（32 对应 float32，64 对应 float64）；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    f, _ := strconv.ParseFloat(<span class="string">&quot;1.234&quot;</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    字符串转有符号整数：strconv.ParseInt</span></span><br><span class="line"><span class="comment">       第一个参数：待解析的字符串；</span></span><br><span class="line"><span class="comment">       第二个参数：进制（0 表示自动识别进制，10 表示十进制，16 表示十六进制等，范围 2-36）；</span></span><br><span class="line"><span class="comment">       第三个参数：整数位宽（8/16/32/64，对应不同长度的有符号整数）；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    i, _ := strconv.ParseInt(<span class="string">&quot;123&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(i)</span><br><span class="line"></span><br><span class="line">    d, _ := strconv.ParseInt(<span class="string">&quot;0x1c8&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(d)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串转无符号整数：strconv.ParseUint</span></span><br><span class="line">    u, _ := strconv.ParseUint(<span class="string">&quot;789&quot;</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">    fmt.Println(u)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化版字符串转整数：strconv.Atoi</span></span><br><span class="line">    k, _ := strconv.Atoi(<span class="string">&quot;135&quot;</span>)</span><br><span class="line">    fmt.Println(k) <span class="comment">// 输出：135</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析非法字符串 &quot;wat&quot;（非数字）</span></span><br><span class="line">    _, e := strconv.Atoi(<span class="string">&quot;wat&quot;</span>)</span><br><span class="line">    fmt.Println(e) <span class="comment">// 输出：strconv.Atoi: parsing &quot;wat&quot;: invalid syntax</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="17-URL-解析"><a href="#17-URL-解析" class="headerlink" title="17.URL 解析"></a>17.URL 解析</h2><p><code>url.Parse()</code> 能将原始 URL 字符串解析为 <code>url.URL</code> 结构体，该结构体封装了 URL 所有标准组件，配合 <code>url.ParseQuery()</code> 可便捷提取查询参数，<code>net.SplitHostPort()</code> 可拆分主机和端口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议]://[用户认证]@[主机:端口]/[路径]?[查询参数]#[锚点]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段名</th>
<th>类型</th>
<th>对应 URL 组件</th>
</tr>
</thead>
<tbody><tr>
<td><code>Scheme</code></td>
<td><code>string</code></td>
<td>协议（如 http、postgres）</td>
</tr>
<tr>
<td><code>User</code></td>
<td><code>*url.Userinfo</code></td>
<td>用户认证（用户名 + 密码）</td>
</tr>
<tr>
<td><code>Host</code></td>
<td><code>string</code></td>
<td>主机名 + 端口（host:port）</td>
</tr>
<tr>
<td><code>Path</code></td>
<td><code>string</code></td>
<td>路径</td>
</tr>
<tr>
<td><code>RawPath</code></td>
<td><code>string</code></td>
<td>未解码的原始路径（含特殊字符）</td>
</tr>
<tr>
<td><code>RawQuery</code></td>
<td><code>string</code></td>
<td>未解析的原始查询参数</td>
</tr>
<tr>
<td><code>Fragment</code></td>
<td><code>string</code></td>
<td>锚点（# 后部分）</td>
</tr>
<tr>
<td><code>RequestURI</code></td>
<td><code>string</code></td>
<td>路径 + 查询参数 + 锚点</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net&quot;</span></span><br><span class="line">    <span class="string">&quot;net/url&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 原始 URL 字符串（包含协议、用户认证、主机端口、路径、查询参数、锚点）</span></span><br><span class="line">    s := <span class="string">&quot;postgres://user:pass@host.com:5432/path?k=v#f&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析 URL：将字符串转为 url.URL 结构体（核心函数）</span></span><br><span class="line">    u, err := url.Parse(s)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取基础组件：协议（Scheme）</span></span><br><span class="line">    fmt.Println(u.Scheme)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提取用户认证信息：用户名 + 密码（User）</span></span><br><span class="line">    fmt.Println(u.User)</span><br><span class="line">    fmt.Println(u.User.Username())</span><br><span class="line">    p, _ := u.User.Password()</span><br><span class="line">    fmt.Println(p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取主机和端口（Host）：配合 net.SplitHostPort</span></span><br><span class="line">    fmt.Println(u.Host)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    net.SplitHostPort(addr string) (host, port string, err error)</span></span><br><span class="line"><span class="comment">    功能：将 host:port 格式的字符串拆分为纯主机名和端口；</span></span><br><span class="line"><span class="comment">    注意：端口返回值是 string 类型，若需整数需用 strconv.Atoi() 转换；</span></span><br><span class="line"><span class="comment">    错误场景：若 addr 无端口（如 host.com）或端口格式非法（如 host.com:abc），会返回错误。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    host, port, _ := net.SplitHostPort(u.Host)</span><br><span class="line">    fmt.Println(host)</span><br><span class="line">    fmt.Println(port)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取路径（Path）和锚点（Fragment）</span></span><br><span class="line">    fmt.Println(u.Path)</span><br><span class="line">    fmt.Println(u.Fragment)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  解析查询参数（Query Parameters）：RawQuery 与 ParseQuery</span></span><br><span class="line">    fmt.Println(u.RawQuery)</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    url.ParseQuery(query string) (url.Values, error)</span></span><br><span class="line"><span class="comment">    功能：将查询参数字符串（如 k=v&amp;a=b&amp;a=c）解析为 url.Values 类型（本质是 map[string][]string）；</span></span><br><span class="line"><span class="comment">    关键特性：</span></span><br><span class="line"><span class="comment">       支持多值参数：若查询参数是 a=b&amp;a=c，解析后 m[&quot;a&quot;] = []string&#123;&quot;b&quot;, &quot;c&quot;&#125;，适合处理同名多值场景（如 ?ids=1&amp;ids=2）；</span></span><br><span class="line"><span class="comment">       自动解码：会自动处理 URL 编码字符（如 ?k=hello%20world 解析后 m[&quot;k&quot;][0] = &quot;hello world&quot;）；</span></span><br><span class="line"><span class="comment">    用法：通过 m[&quot;key&quot;][0] 获取单值参数，通过遍历 m[&quot;key&quot;] 获取多值参数。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    m, _ := url.ParseQuery(u.RawQuery)</span><br><span class="line">    fmt.Println(m)</span><br><span class="line">    fmt.Println(m[<span class="string">&quot;k&quot;</span>][<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-SHA256-散列"><a href="#18-SHA256-散列" class="headerlink" title="18.SHA256 散列"></a>18.SHA256 散列</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;crypto/sha256&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s := <span class="string">&quot;sha256 this string&quot;</span></span><br><span class="line"></span><br><span class="line">    h := sha256.New()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入要处理的字节。如果是一个字符串， 需要使用 []byte(s) 将其强制转换成字节数组。</span></span><br><span class="line">    h.Write([]<span class="type">byte</span>(s))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完成哈希计算，返回最终的 SHA-256 哈希值（字节切片类型）</span></span><br><span class="line">    bs := h.Sum(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(s)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SHA256 值经常以 16 进制输出，例如在 git commit 中。</span></span><br><span class="line">    <span class="comment">// 我们这里也使用 %x 来将散列结果格式化为 16 进制字符串</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%x\n&quot;</span>, bs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键注意点</strong></p>
<ol>
<li><strong>数据类型转换</strong>：SHA-256 仅处理字节数据，必须将字符串、数字等转为 <code>[]byte</code> 后再写入哈希器；</li>
<li><strong>哈希器的复用</strong>：计算多个数据的哈希时，必须调用 <code>h.Reset()</code> 重置状态，否则会将多个数据的字节拼接后计算哈希（如不重置，第二次写入会追加到第一次数据后）；</li>
<li><strong>哈希值的不可逆性</strong>：SHA-256 是单向哈希，无法从哈希值反推原始数据（如无法从示例中的 64 位字符串得到 <code>&quot;sha256 this string&quot;</code>）；</li>
<li><strong>抗碰撞性</strong>：不要依赖 SHA-256 进行「加密」（无密钥），其核心用途是「数据完整性校验」（如验证文件是否被篡改）、「密码存储」（存储密码的哈希值，而非明文）；</li>
<li><strong>安全场景补充</strong>：若用于密码存储，需添加「盐值（Salt）」（如 <code>h.Write(append(salt, []byte(password)...))</code>），避免彩虹表破解；若需更高安全性，可使用 SHA-512（<code>crypto/sha512</code> 包，用法完全一致，输出 128 位十六进制字符串）。</li>
</ol>
<h2 id="19-base64编码"><a href="#19-base64编码" class="headerlink" title="19.base64编码"></a>19.base64编码</h2><p><strong>核心概念</strong></p>
<ol>
<li><strong>Base64 编码原理</strong>：将 3 字节（24 位）的二进制数据，按每 6 位分组（6 位对应 0-63 的整数），每个分组映射到 Base64 字符表中的一个字符；若数据长度不是 3 的倍数，会自动补零，最终用 <code>=</code> 符号填充（标准 Base64）。</li>
<li><strong>两种编码方案：</strong><ul>
<li>标准 Base64（<code>StdEncoding</code>）：字符表包含 <code>A-Z、a-z、0-9、+、/</code>，补位用 <code>=</code>；</li>
<li>URL 安全 Base64（<code>URLEncoding</code>）：字符表包含 <code>A-Z、a-z、0-9、-、_</code>，<strong>无补位符号</strong>（<code>=</code> 会被省略），避免 <code>+、/、=</code> 等字符在 URL&#x2F; Cookie 中被转义（如 <code>+</code> 会被解析为空格）。</li>
</ul>
</li>
<li><strong>编码特性</strong>：编码后的数据长度约为原始数据的 1.33 倍（3 字节→4 字符），可逆（编码后的数据可完全解码回原始数据）。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    b64 <span class="string">&quot;encoding/base64&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    data := <span class="string">&quot;abc123!?$*&amp;()&#x27;-=@~&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准 Base64 编码：字符串→字节切片→Base64 编码字符串</span></span><br><span class="line">    sEnc := b64.StdEncoding.EncodeToString([]<span class="type">byte</span>(data))</span><br><span class="line">    fmt.Println(sEnc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准 Base64 解码：Base64 编码字符串→字节切片→原始字符串</span></span><br><span class="line">    sDec, _ := b64.StdEncoding.DecodeString(sEnc)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(sDec))</span><br><span class="line">    fmt.Println()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL 安全 Base64 编码：字节切片→URL 安全 Base64 字符串</span></span><br><span class="line">    uEnc := b64.URLEncoding.EncodeToString([]<span class="type">byte</span>(data))</span><br><span class="line">    fmt.Println(uEnc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// URL 安全 Base64 解码：URL 安全 Base64 字符串→原始字节切片</span></span><br><span class="line">    uDec, _ := b64.URLEncoding.DecodeString(uEnc)</span><br><span class="line">    fmt.Println(<span class="type">string</span>(uDec))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>编码方案</th>
<th>编码函数</th>
<th>解码函数</th>
<th>适用场景</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>标准 Base64</td>
<td><code>b64.StdEncoding.EncodeToString(p []byte)</code></td>
<td><code>b64.StdEncoding.DecodeString(s string)</code></td>
<td>普通文本 &#x2F; 二进制数据编码（如文件传输、配置存储）</td>
<td>字符表含 <code>+、/</code>，补位用 <code>=</code></td>
</tr>
<tr>
<td>URL 安全 Base64</td>
<td><code>b64.URLEncoding.EncodeToString(p []byte)</code></td>
<td><code>b64.URLEncoding.DecodeString(s string)</code></td>
<td>URL 参数、Cookie、Token 编码</td>
<td>字符表含 <code>-、_</code>，无 <code>=</code> 补位，避免转义</td>
</tr>
</tbody></table>
<h2 id="20-读文件"><a href="#20-读文件" class="headerlink" title="20.读文件"></a>20.读文件</h2><p>Go 读取文件的核心是 <code>os.Open()</code>（打开文件获取文件句柄）和 <code>os.ReadFile()</code>（简化版一次性读取），配合 <code>io</code> 包的底层读取函数、<code>bufio</code> 的缓冲读取、<code>Seek()</code> 的随机定位，可灵活应对不同大小、不同读取需求的文件。</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>文件句柄（<code>*os.File</code>）</strong>：通过 <code>os.Open()</code> 打开文件后返回的指针，是所有文件读取操作的基础（类似 “文件的操作入口”），使用后必须调用 <code>Close()</code> 关闭（避免资源泄露）；</li>
<li><strong>读取模式：</strong><ul>
<li>一次性读取：将整个文件加载到内存（适合小文件）；</li>
<li>分批读取：按固定字节数读取（适合大文件，避免内存溢出）；</li>
<li>随机读取：通过 <code>Seek()</code> 定位到文件任意位置读取（无需顺序遍历）；</li>
<li>缓冲读取：通过 <code>bufio.Reader</code> 减少系统调用次数（提高读取效率，适合频繁小批量读取）；</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;io&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">check</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 1：一次性读取整个文件（os.ReadFile，推荐小文件）</span></span><br><span class="line"><span class="comment">    核心函数：os.ReadFile(path string) ([]byte, error)</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       最简洁的读取方式：无需手动打开 / 关闭文件（ReadFile 内部已封装 Open() 和 Close()）；</span></span><br><span class="line"><span class="comment">       底层逻辑：将文件全部内容加载到内存，返回字节切片；</span></span><br><span class="line"><span class="comment">       适用场景：小文件（如配置文件、日志片段），大文件（如 1GB 以上）不推荐（会导致内存溢出）；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dat, err := os.ReadFile(<span class="string">&quot;/tmp/dat&quot;</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Print(<span class="type">string</span>(dat))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 2：打开文件获取句柄（os.Open，为后续复杂读取做准备）</span></span><br><span class="line"><span class="comment">    核心函数：os.Open(path string) (*os.File, error)</span></span><br><span class="line"><span class="comment">    功能：以“只读模式”打开文件，返回文件句柄（*os.File）和错误</span></span><br><span class="line"><span class="comment">    关键说明：</span></span><br><span class="line"><span class="comment">       os.Open() 仅支持 “只读模式”，若需写入需用 os.OpenFile() 并指定权限；</span></span><br><span class="line"><span class="comment">       defer f.Close()：将 Close() 延迟到当前函数（main）结束时执行，是 Go 中关闭文件句柄的标准写法（避免遗漏关闭）；</span></span><br><span class="line"><span class="comment">       后续所有读取操作（用法 3 - 用法 6）都基于这个文件句柄 f。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    f, err := os.Open(<span class="string">&quot;/tmp/dat&quot;</span>)</span><br><span class="line">    check(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：文件句柄使用后必须关闭（避免资源泄露）</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// 推荐用 defer 延迟关闭（函数结束时自动执行，即使中间出错也能关闭）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 3：固定字节数读取（f.Read，分批读取大文件）</span></span><br><span class="line"><span class="comment">    创建字节切片作为“读取缓冲区”（容量 5 字节，即每次读取 5 字节）</span></span><br><span class="line"><span class="comment">    核心方法：f.Read(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">        功能：从文件当前位置读取数据到缓冲区 p</span></span><br><span class="line"><span class="comment">        返回值：n 是实际读取到的字节数（可能小于缓冲区容量，如文件末尾），err 是错误</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       按缓冲区大小分批读取，适合大文件（如读取 1GB 日志文件，每次读 1MB 缓冲区）；</span></span><br><span class="line"><span class="comment">       读取位置是 “连续的”：第一次读取 5 字节后，文件指针自动移动到第 5 字节后，下次读取从第 6 字节开始；</span></span><br><span class="line"><span class="comment">       注意：b1[:n1] 是关键 —— 若文件剩余字节数小于缓冲区容量（如文件只剩 3 字节，缓冲区是 5 字节），n1=3，仅需处理前 3 字节。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    b1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">5</span>)</span><br><span class="line">    n1, err := f.Read(b1)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d bytes: %s\n&quot;</span>, n1, <span class="type">string</span>(b1[:n1]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 4：随机位置读取（f.Seek + f.Read，定位读取）</span></span><br><span class="line"><span class="comment">    核心方法：f.Seek(offset int64, whence int) (int64, error)</span></span><br><span class="line"><span class="comment">       - 功能：将文件指针定位到指定位置</span></span><br><span class="line"><span class="comment">       - 参数：</span></span><br><span class="line"><span class="comment">         - offset：偏移量（字节数）；</span></span><br><span class="line"><span class="comment">         - whence：定位基准（0=从文件开头开始，1=从当前位置开始，2=从文件末尾开始）；</span></span><br><span class="line"><span class="comment">       - 返回值：定位后的绝对位置（从文件开头算起）</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       无需顺序读取，可直接定位到文件任意位置（如读取大文件的中间某段内容）；</span></span><br><span class="line"><span class="comment">       常见场景：读取固定格式的文件（如文件头 10 字节是元数据，直接定位到第 10 字节读取数据体）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    o2, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>) <span class="comment">// 从文件开头（0）偏移 6 字节（定位到第 6 字节，索引从 0 开始）</span></span><br><span class="line">    check(err)</span><br><span class="line">    <span class="comment">//  创建缓冲区（容量 2 字节）</span></span><br><span class="line">    b2 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    n2, err := f.Read(b2)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d bytes @ %d: &quot;</span>, n2, o2)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="type">string</span>(b2[:n2]))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 5：按最少字节数读取（io.ReadAtLeast，确保读取到足够数据）</span></span><br><span class="line"><span class="comment">    核心函数：io.ReadAtLeast(r io.Reader, buf []byte, min int) (n int, err error)</span></span><br><span class="line"><span class="comment">       - 功能：从 r（文件句柄实现了 io.Reader 接口）读取数据到 buf，确保至少读取 min 字节</span></span><br><span class="line"><span class="comment">       - 错误场景：若文件剩余字节数小于 min，会返回错误（io.ErrUnexpectedEOF）</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       比 f.Read() 更严格：f.Read() 可能读取到少于缓冲区容量的字节（如文件末尾），而 io.ReadAtLeast() 会一直读取直到满足 min 字节数（或出错）；</span></span><br><span class="line"><span class="comment">       适用场景：必须读取固定长度数据的场景（如网络协议解析、二进制文件格式解析，要求每次必须读 8 字节）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    o3, err := f.Seek(<span class="number">6</span>, <span class="number">0</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    b3 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">2</span>)</span><br><span class="line">    n3, err := io.ReadAtLeast(f, b3, <span class="number">2</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d bytes @ %d: %s\n&quot;</span>, n3, o3, <span class="type">string</span>(b3))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 6：带缓冲读取（bufio.NewReader + Peek，高效预览 / 读取）</span></span><br><span class="line"><span class="comment">    核心函数：bufio.NewReader(r io.Reader) *bufio.Reader</span></span><br><span class="line"><span class="comment">       - 功能：创建带缓冲的读取器（默认缓冲区大小 4096 字节，可通过 bufio.NewReaderSize 自定义）</span></span><br><span class="line"><span class="comment">    核心方法：r4.Peek(n int) ([]byte, error)</span></span><br><span class="line"><span class="comment">       - 功能：预览文件当前位置的前 n 字节（不会移动文件指针，仅“查看”）</span></span><br><span class="line"><span class="comment">       - 区别于 Read：Read 会消耗数据（文件指针移动），Peek 仅预览（指针不动）</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       高效：缓冲读取器会提前读取一批数据到内存缓冲区，后续读取从缓冲区获取，减少系统调用次数（系统调用开销大，缓冲可显著提升读取效率）；</span></span><br><span class="line"><span class="comment">       Peek() 预览功能：适合需要 “先查看数据再决定如何读取” 的场景（如解析文件格式时，先预览文件头判断编码方式）；</span></span><br><span class="line"><span class="comment">    常用方法补充：</span></span><br><span class="line"><span class="comment">       r4.ReadBytes(delim byte)：读取到分隔符 delim 为止（如按行读取用 &#x27;\n&#x27;）；</span></span><br><span class="line"><span class="comment">       r4.ReadString(delim byte)：与 ReadBytes 类似，返回字符串；</span></span><br><span class="line"><span class="comment">       r4.ReadLine()：按行读取（自动处理 \n 或 \r\n 换行符）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将文件指针重置到文件开头（之前已读取到中间位置）</span></span><br><span class="line">    _, err = f.Seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    check(err)</span><br><span class="line"></span><br><span class="line">    r4 := bufio.NewReader(f)</span><br><span class="line">    b4, err := r4.Peek(<span class="number">5</span>)</span><br><span class="line">    check(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;5 bytes: %s\n&quot;</span>, <span class="type">string</span>(b4))</span><br><span class="line"></span><br><span class="line">    f.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法总结</strong></p>
<table>
<thead>
<tr>
<th>读取场景</th>
<th>核心函数 &#x2F; 方法</th>
<th>适用场景</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>小文件一次性读取</td>
<td><code>os.ReadFile(path)</code></td>
<td>配置文件、小日志文件（&lt;10MB）</td>
<td>简洁，无需手动管理文件句柄</td>
</tr>
<tr>
<td>大文件分批读取</td>
<td><code>f.Read(buf []byte)</code></td>
<td>大文件（&gt;100MB）、流数据</td>
<td>控制内存占用，避免溢出</td>
</tr>
<tr>
<td>随机位置读取</td>
<td><code>f.Seek(offset, whence)</code> + <code>f.Read()</code></td>
<td>固定格式文件、按需读取中间内容</td>
<td>灵活定位，无需顺序遍历</td>
</tr>
<tr>
<td>确保读取固定字节数</td>
<td><code>io.ReadAtLeast(r, buf, min)</code></td>
<td>协议解析、二进制文件解析</td>
<td>严格保证读取长度，失败报错</td>
</tr>
<tr>
<td>高效预览 &#x2F; 频繁小读取</td>
<td><code>bufio.NewReader(r)</code> + <code>Peek()</code>&#x2F;<code>ReadString()</code></td>
<td>按行读取、频繁小批量读取</td>
<td>缓冲减少系统调用，支持预览、按分隔符读取</td>
</tr>
</tbody></table>
<p><strong>关键注意点</strong></p>
<ol>
<li><strong>文件句柄必须关闭</strong>：<ul>
<li>忘记关闭文件句柄会导致系统资源泄露（文件描述符耗尽），推荐用 <code>defer f.Close()</code> 延迟关闭（在 <code>os.Open()</code> 后立即调用）；</li>
<li>错误示例：<code>f, err := os.Open(path); // 无 defer f.Close()</code> → 函数结束后文件句柄未关闭。</li>
</ul>
</li>
<li><strong>缓冲区与实际读取字节数</strong>：<ul>
<li><code>f.Read(buf)</code> 返回的 <code>n</code>（实际读取字节数）可能小于缓冲区容量（如文件末尾），必须用 <code>buf[:n]</code> 处理数据（避免缓冲区未填满的空字符）；</li>
<li>错误示例：<code>b := make([]byte, 5); f.Read(b); fmt.Println(string(b))</code> → 若文件只剩 3 字节，输出会包含 2 个空字符。</li>
</ul>
</li>
<li><strong>大文件避免一次性读取</strong>：<ul>
<li><code>os.ReadFile()</code> 会将整个文件加载到内存，读取 1GB 以上的大文件会导致 <code>OOM</code>（内存溢出），必须用分批读取（<code>f.Read()</code>）或缓冲读取（<code>bufio</code>）；</li>
</ul>
</li>
<li><strong>错误处理不能少</strong>：<ul>
<li>文件读取的常见错误：文件不存在、权限不足、文件被占用、读取过程中文件被删除，必须处理这些错误（示例用 <code>panic</code>，实际开发可记录日志并优雅退出）；</li>
<li>特殊错误：<code>io.EOF</code>（文件结束符），当 <code>f.Read()</code> 返回 <code>n&gt;0</code> 且 <code>err=io.EOF</code> 时，说明已读取到文件末尾，需正常处理已读取的 <code>n</code> 字节数据。</li>
</ul>
</li>
<li><strong><code>Seek()</code> 的定位基准</strong>：<ul>
<li><code>whence=0</code>（默认）：从文件开头计算偏移量（最常用）；</li>
<li><code>whence=1</code>：从当前文件指针位置计算偏移量（如 <code>f.Seek(2, 1)</code> 表示从当前位置向后移动 2 字节）；</li>
<li><code>whence=2</code>：从文件末尾计算偏移量（如 <code>f.Seek(-5, 2)</code> 表示定位到文件末尾前 5 字节）。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><strong>核心选择逻辑：</strong><ul>
<li>小文件：优先用 <code>os.ReadFile()</code>（简洁高效）；</li>
<li>大文件：用 <code>f.Read()</code> 分批读取或 <code>bufio</code> 缓冲读取（控制内存）；</li>
<li>随机读取：<code>f.Seek()</code> + 任意读取方法；</li>
<li>按行 &#x2F; 按分隔符读取：<code>bufio.Reader</code> 的 <code>ReadLine()</code>&#x2F;<code>ReadString()</code>；</li>
</ul>
</li>
<li><strong>关键原则：</strong><ul>
<li>文件句柄必须关闭（<code>defer f.Close()</code>）；</li>
<li>处理实际读取字节数（<code>buf[:n]</code>）；</li>
<li>不忽视错误（尤其是 <code>io.EOF</code>）；</li>
</ul>
</li>
<li><strong>简单记</strong>：“小文件一次读，大文件分批读，随机读取用 Seek，高效读取用 bufio”。</li>
</ol>
<h2 id="21-写文件"><a href="#21-写文件" class="headerlink" title="21.写文件"></a>21.写文件</h2><p>Go 写入文件的核心是 <code>os.WriteFile()</code>（简化版一次性写入）和 <code>os.Create()</code>（创建文件获取句柄后写入），配合 <code>Write()</code>（字节写入）、<code>WriteString()</code>（字符串写入）、<code>Sync()</code>（强制刷盘）、<code>bufio.Writer</code>（缓冲写入），可灵活应对不同大小、不同效率要求的文件写入需求。</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>文件写入模式：</strong><ul>
<li>一次性写入：直接将字节切片写入文件（覆盖原有内容，无则创建）；</li>
<li>句柄写入：先创建 &#x2F; 打开文件获取句柄（<code>*os.File</code>），通过句柄多次写入（支持追加、覆盖等模式）；</li>
<li>缓冲写入：通过缓冲区暂存数据，批量刷盘（减少系统调用，提升大文件写入效率）；</li>
</ul>
</li>
<li>**文件权限（Mode）：**示例中<code>0644</code>是 Unix 风格的文件权限（<code>rw-r--r--</code>），表示：<ul>
<li>所有者（owner）：可读可写（<code>6 = 4+2</code>）；</li>
<li>组用户（group）：只读（<code>4</code>）；</li>
<li>其他用户（others）：只读（<code>4</code>）；</li>
<li>Windows 系统会忽略权限设置，但仍需传入合法值（如 <code>0644</code>）；</li>
</ul>
</li>
<li><strong>资源释放</strong>：通过 <code>os.Create()</code> 获取的文件句柄，必须调用 <code>Close()</code> 关闭（<code>defer f.Close()</code> 是标准写法），避免资源泄露。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkFile</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 1：一次性写入整个文件（os.WriteFile，推荐小文件）</span></span><br><span class="line"><span class="comment">    核心函数：os.WriteFile(path string, data []byte, perm os.FileMode) error</span></span><br><span class="line"><span class="comment">       - 功能：创建文件（无则创建，有则覆盖原有内容），写入数据后自动关闭文件；</span></span><br><span class="line"><span class="comment">       - 参数：</span></span><br><span class="line"><span class="comment">         - path：文件路径；</span></span><br><span class="line"><span class="comment">         - data：待写入的字节切片；</span></span><br><span class="line"><span class="comment">         - perm：文件权限（Unix 风格，Windows 忽略）；</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       最简洁的写入方式：无需手动打开 / 关闭文件（内部封装 OpenFile() 和 Close()）；</span></span><br><span class="line"><span class="comment">       覆盖特性：若文件已存在，会直接覆盖原有内容（不会追加）；</span></span><br><span class="line"><span class="comment">       适用场景：小文件（如配置文件、临时文件），无需多次写入的场景；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    d1 := []<span class="type">byte</span>(<span class="string">&quot;hello\ngo\n&quot;</span>)</span><br><span class="line">    err := os.WriteFile(<span class="string">&quot;/tmp/dat1&quot;</span>, d1, <span class="number">0644</span>)</span><br><span class="line">    checkFile(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 2：创建文件获取句柄（os.Create，为多次写入做准备）</span></span><br><span class="line"><span class="comment">    核心函数：os.Create(path string) (*os.File, error)</span></span><br><span class="line"><span class="comment">       - 功能：创建文件（无则创建，有则清空原有内容），返回文件句柄（*os.File）和错误；</span></span><br><span class="line"><span class="comment">       - 等价于：os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0666)（默认权限 0666）；</span></span><br><span class="line"><span class="comment">    关键说明：</span></span><br><span class="line"><span class="comment">       os.Create() 的核心是「创建 + 清空」：若文件已存在，会清空所有内容后重新写入；</span></span><br><span class="line"><span class="comment">       文件句柄 f 是后续所有写入操作的基础（支持多次写入、混合写入）；</span></span><br><span class="line"><span class="comment">       若需「追加写入」（而非覆盖），需用 os.OpenFile() 并指定 os.O_APPEND 标志</span></span><br><span class="line"><span class="comment">       （如 os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    f, err := os.Create(<span class="string">&quot;/tmp/dat2&quot;</span>)</span><br><span class="line">    checkFile(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟关闭文件句柄（关键：避免资源泄露，函数结束时自动执行）</span></span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 3：字节切片写入（f.Write，底层基础写入）</span></span><br><span class="line"><span class="comment">    核心方法：f.Write(p []byte) (n int, err error)</span></span><br><span class="line"><span class="comment">       - 功能：将字节切片 p 写入文件（从当前文件指针位置开始）；</span></span><br><span class="line"><span class="comment">       - 返回值：n 是实际写入的字节数（正常情况下等于 len(p)），err 是错误；</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       底层写入方法：所有字符串写入最终都会转为字节写入，效率较高；</span></span><br><span class="line"><span class="comment">       写入位置：默认从文件开头开始（os.Create 会清空文件，指针在开头），多次写入会依次追加；</span></span><br><span class="line"><span class="comment">       适用场景：二进制数据写入（如图片、视频、序列化数据）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    d2 := []<span class="type">byte</span>&#123;<span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>, <span class="number">10</span>&#125;</span><br><span class="line">    n2, err := f.Write(d2)</span><br><span class="line">    checkFile(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 4：字符串直接写入（f.WriteString，便捷字符串场景）</span></span><br><span class="line"><span class="comment">    核心方法：f.WriteString(s string) (n int, err error)</span></span><br><span class="line"><span class="comment">       - 功能：直接将字符串 s 写入文件（内部自动转为字节切片，无需手动转换）；</span></span><br><span class="line"><span class="comment">       - 返回值：n 是实际写入的字节数（等于 len(s)），err 是错误；</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       便捷性：无需手动执行 []byte(s) 转换，适合频繁写入字符串的场景（如日志写入）；</span></span><br><span class="line"><span class="comment">       效率：与 f.Write([]byte(s)) 效率一致（内部仅多一层转换，无额外开销）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    n3, err := f.WriteString(<span class="string">&quot;writes\n&quot;</span>)</span><br><span class="line">    checkFile(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 5：强制刷盘（f.Sync，数据安全优先场景）</span></span><br><span class="line"><span class="comment">    核心方法：f.Sync() error</span></span><br><span class="line"><span class="comment">       功能：将文件缓冲区（操作系统层面的缓冲区）中的数据强制刷写到磁盘；</span></span><br><span class="line"><span class="comment">       背景：操作系统为提升效率，会将写入数据暂存到内存缓冲区，定期批量刷盘（默认延迟约 30 秒）；</span></span><br><span class="line"><span class="comment">       适用场景：数据安全优先的场景（如数据库写入、日志记录、金融交易数据），避免断电 / 系统崩溃导致数据丢失；</span></span><br><span class="line"><span class="comment">       注意：Sync() 是阻塞操作，会等待刷盘完成，频繁调用会降低写入效率。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    f.Sync()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    用法 6：带缓冲写入（bufio.Writer，高效批量写入）</span></span><br><span class="line"><span class="comment">    核心函数：bufio.NewWriter(w io.Writer) *bufio.Writer</span></span><br><span class="line"><span class="comment">       - 功能：创建带缓冲的写入器（默认缓冲区大小 4096 字节，可通过 bufio.NewWriterSize 自定义）；</span></span><br><span class="line"><span class="comment">       - 原理：将数据先写入内存缓冲区，缓冲区满或调用 Flush() 时，批量刷写到文件（减少系统调用次数）；</span></span><br><span class="line"><span class="comment">    核心方法：w.Flush() error</span></span><br><span class="line"><span class="comment">       - 功能：强制将缓冲区中的数据刷写到文件（必须调用，否则缓冲区数据可能未写入磁盘）；</span></span><br><span class="line"><span class="comment">    核心特点：</span></span><br><span class="line"><span class="comment">       高效：减少系统调用（系统调用开销大，批量刷盘可提升 10x+ 效率），适合大文件写入、频繁小批量写入（如日志输出）；</span></span><br><span class="line"><span class="comment">    注意事项：</span></span><br><span class="line"><span class="comment">       必须调用 w.Flush()：否则缓冲区中的数据不会写入文件（程序退出时缓冲区可能丢失）；</span></span><br><span class="line"><span class="comment">       缓冲区大小：默认 4KB，若写入数据量大（如每次写 1MB），可自定义更大缓冲区（如 bufio.NewWriterSize(f, 1024*1024)）；</span></span><br><span class="line"><span class="comment">    与 f.Sync() 的区别：</span></span><br><span class="line"><span class="comment">       Flush() 是将 Go 程序层面的缓冲区刷到操作系统缓冲区，Sync() 是将操作系统缓冲区刷到磁盘（数据安全场景需两者结合：w.Flush() + f.Sync()）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    w := bufio.NewWriter(f)</span><br><span class="line">    n4, err := w.WriteString(<span class="string">&quot;buffered\n&quot;</span>) <span class="comment">// 缓冲写入字符串（与 f.WriteString 用法一致，但写入缓冲区）</span></span><br><span class="line">    checkFile(err)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;wrote %d bytes\n&quot;</span>, n4)</span><br><span class="line"></span><br><span class="line">    w.Flush()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法总结</strong></p>
<table>
<thead>
<tr>
<th>写入场景</th>
<th>核心函数 &#x2F; 方法</th>
<th>适用场景</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>小文件一次性写入</td>
<td><code>os.WriteFile(path, data, perm)</code></td>
<td>配置文件、临时文件（&lt;10MB）</td>
<td>简洁，无需手动管理文件句柄</td>
</tr>
<tr>
<td>多次写入 &#x2F; 混合写入</td>
<td><code>os.Create(path)</code> + <code>f.Write()</code>&#x2F;<code>f.WriteString()</code></td>
<td>多段数据写入、字符串 + 字节混合写入</td>
<td>灵活控制写入内容，支持追加（需改 OpenFile 标志）</td>
</tr>
<tr>
<td>字符串便捷写入</td>
<td><code>f.WriteString(s)</code></td>
<td>日志写入、文本内容写入</td>
<td>无需手动转换字节切片，代码简洁</td>
</tr>
<tr>
<td>数据安全优先写入</td>
<td><code>f.Sync()</code></td>
<td>数据库、金融数据、关键日志</td>
<td>强制刷盘，避免数据丢失（阻塞操作）</td>
</tr>
<tr>
<td>大文件 &#x2F; 频繁写入</td>
<td><code>bufio.NewWriter(f)</code> + <code>w.WriteString()</code> + <code>w.Flush()</code></td>
<td>日志输出、大文件写入（&gt;100MB）</td>
<td>缓冲批量刷盘，减少系统调用，提升效率</td>
</tr>
<tr>
<td>二进制数据写入</td>
<td><code>f.Write(p []byte)</code></td>
<td>图片、视频、序列化数据</td>
<td>底层写入方法，效率高</td>
</tr>
</tbody></table>
<p><strong>关键注意点</strong></p>
<ol>
<li><strong>文件句柄必须关闭</strong>：<ul>
<li>用 <code>os.Create()</code>&#x2F;<code>os.OpenFile()</code> 获取的句柄，必须调用 <code>Close()</code> 关闭（<code>defer f.Close()</code> 是标准写法）；</li>
<li>若未关闭，可能导致缓冲区数据未刷盘（数据丢失）或系统资源泄露（文件描述符耗尽）。</li>
</ul>
</li>
<li><strong><code>os.WriteFile</code> 的覆盖特性</strong>：<ul>
<li>若文件已存在，<code>os.WriteFile()</code> 会直接覆盖原有内容（不会追加）；</li>
<li>若需追加写入，需用 <code>os.OpenFile(path, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)</code> 打开文件后写入。</li>
</ul>
</li>
<li><strong>缓冲写入必须调用 <code>Flush()</code></strong>：<ul>
<li><code>bufio.Writer</code> 的写入操作仅将数据写入内存缓冲区，未实际写入文件；</li>
<li>必须调用 <code>w.Flush()</code> 才能将缓冲区数据刷到文件（程序退出前务必调用，否则数据丢失）。</li>
</ul>
</li>
<li><strong><code>Sync()</code> 与 <code>Flush()</code> 的区别</strong>：<ul>
<li><code>Flush()</code>：Go 程序 → 操作系统缓冲区（非持久化，断电可能丢失）；</li>
<li><code>Sync()</code>：操作系统缓冲区 → 磁盘（持久化，数据安全）；</li>
<li>数据安全场景（如交易记录）：需先 <code>Flush()</code> 再 <code>Sync()</code>（<code>w.Flush(); f.Sync()</code>）。</li>
</ul>
</li>
<li><strong>文件权限的兼容性</strong>：<ul>
<li>Unix&#x2F;Linux&#x2F;Mac 系统严格遵循 <code>perm</code> 权限设置（如 <code>0644</code>）；</li>
<li>Windows 系统忽略权限设置，但仍需传入合法值（如 <code>0644</code>、<code>0755</code>），否则会报错。</li>
</ul>
</li>
<li><strong>错误处理不能少</strong>：<ul>
<li>写入文件的常见错误：权限不足（无法创建文件）、磁盘空间不足、文件被占用，必须处理这些错误；</li>
<li>示例用 <code>panic</code> 简化错误处理，实际开发中应记录日志并优雅退出（如 <code>log.Fatal(err)</code>）。</li>
</ul>
</li>
</ol>
<p><strong>总结</strong></p>
<ol>
<li><strong>核心选择逻辑：</strong><ul>
<li>小文件一次性写入：优先用 <code>os.WriteFile()</code>（简洁高效）；</li>
<li>多次 &#x2F; 混合写入：用 <code>os.Create()</code> 获取句柄，配合 <code>Write()</code>&#x2F;<code>WriteString()</code>；</li>
<li>高效批量写入：用 <code>bufio.Writer</code> + <code>Flush()</code>（减少系统调用）；</li>
<li>数据安全写入：加 <code>f.Sync()</code>（强制刷盘）；</li>
</ul>
</li>
<li><strong>关键原则：</strong><ul>
<li>句柄必须关闭（<code>defer f.Close()</code>）；</li>
<li>缓冲必须 <code>Flush()</code>；</li>
<li>安全必须 <code>Sync()</code>；</li>
<li>错误必须处理；</li>
</ul>
</li>
<li><strong>简单记</strong>：“小文件一次写，多次写入用句柄，高效写入用缓冲，安全写入加 Sync”。</li>
</ol>
<h2 id="22-行过滤器"><a href="#22-行过滤器" class="headerlink" title="22.行过滤器"></a>22.行过滤器</h2><p>行过滤器的核心是 <code>bufio.Scanner</code>（逐行读取输入流）+ 自定义处理逻辑 + 错误处理，适用于「逐行处理文本流」的场景（终端输入、文件管道、日志分析等）。</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>行过滤器（Line Filter）</strong>：一种命令行程序模式，特点是「从标准输入（<code>os.Stdin</code>）读取数据，按行处理，处理结果输出到标准输出（<code>os.Stdout</code>）」，不依赖本地文件，靠管道（<code>|</code>）或重定向（<code>&lt;</code>&#x2F;<code>&gt;</code>）传递数据；</li>
<li><strong>核心组件：</strong><ul>
<li><code>bufio.Scanner</code>：Go 标准库提供的「逐行读取器」，自动处理换行符（<code>\n</code>&#x2F;<code>\r\n</code>），无需手动分割行；</li>
<li><code>os.Stdin</code>：标准输入流（默认是终端键盘输入，也可通过管道 &#x2F; 重定向改为文件输入）；</li>
<li><code>os.Stdout</code>：标准输出流（默认是终端显示，也可重定向到文件）；</li>
</ul>
</li>
<li><strong>使用方式：</strong><ul>
<li>终端直接输入：运行程序后，键盘输入一行，程序输出处理后的结果；</li>
<li>管道输入：<code>cat 文件名 | go run 程序.go</code>（将文件内容作为输入，逐行处理）；</li>
<li>重定向输入：<code>go run 程序.go &lt; 文件名</code>（读取文件内容作为输入）。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心函数：bufio.NewScanner(r io.Reader) *bufio.Scanner</span></span><br><span class="line">    <span class="comment">// 功能：创建一个扫描器，从 io.Reader 接口读取数据（os.Stdin 实现了 io.Reader）</span></span><br><span class="line">    <span class="comment">// 作用：自动按行分割输入，处理换行符（\n 或 \r\n），无需手动处理</span></span><br><span class="line">    scanner := bufio.NewScanner(os.Stdin)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心方法：scanner.Scan() bool</span></span><br><span class="line">    <span class="comment">// 功能：扫描下一行数据，返回 bool 值（true 表示扫描到数据，false 表示扫描结束或出错）</span></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">       <span class="comment">// 核心方法：scanner.Text() string → 获取当前扫描到的行（已去除末尾的换行符）</span></span><br><span class="line">       ucl := strings.ToUpper(scanner.Text())</span><br><span class="line"></span><br><span class="line">       fmt.Println(ucl)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心方法：scanner.Err() error → 获取扫描过程中的错误（如输入流读取失败）</span></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       fmt.Fprintln(os.Stderr, <span class="string">&quot;error:&quot;</span>, err)</span><br><span class="line">       os.Exit(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-文件路径"><a href="#23-文件路径" class="headerlink" title="23.文件路径"></a>23.文件路径</h2><p><code>path/filepath</code> 是 Go 处理文件路径的首选包，提供的 API 均为跨平台设计，能避免直接拼接字符串导致的路径格式错误，配合 <code>strings</code> 包可完成路径的全生命周期操作（拼接→拆解→判断→转换）。</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>路径分隔符：</strong><ul>
<li>Unix&#x2F;Linux&#x2F;Mac：路径分隔符为 <code>/</code>（如 <code>/home/user/file.txt</code>）；</li>
<li>Windows：路径分隔符为 <code>\</code>（如 <code>C:\Users\file.txt</code>）；</li>
<li><code>path/filepath</code> 包的 API 会自动识别操作系统，统一处理分隔符（无需手动判断系统）；</li>
</ul>
</li>
<li><strong>关键路径术语：</strong><ul>
<li>绝对路径：从根目录开始的完整路径（如 <code>/a/b/c</code>、<code>C:\a\b</code>）；</li>
<li>相对路径：从当前目录开始的路径（如 <code>../a/b</code>、<code>dir/file.txt</code>）；</li>
<li>目录路径：路径的 “文件夹部分”（如 <code>dir1/dir2/filename</code> 的目录路径是 <code>dir1/dir2</code>）；</li>
<li>文件名：路径的 “文件部分”（如 <code>dir1/dir2/filename</code> 的文件名是 <code>filename</code>）；</li>
<li>扩展名：文件名中 <code>.</code> 后的部分（如 <code>config.json</code> 的扩展名为 <code>.json</code>）。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    核心函数：filepath.Join(elem ...string) string</span></span><br><span class="line"><span class="comment">       功能：将多个路径片段拼接为一个标准化路径，自动处理 3 个关键问题：</span></span><br><span class="line"><span class="comment">       跨平台分隔符：根据系统自动用 / 或 \ 拼接；</span></span><br><span class="line"><span class="comment">       多余分隔符：合并连续的 / 或 \（如 dir1//dir2 → dir1/dir2）；</span></span><br><span class="line"><span class="comment">       路径跳转：解析 ..（上一级目录）和 .（当前目录）（如 dir1/../dir2 → dir2）；</span></span><br><span class="line"><span class="comment">    关键优势：避免手动拼接字符串（如 dir1 + &quot;/&quot; + dir2）导致的跨平台错误或格式混乱；</span></span><br><span class="line"><span class="comment">    注意：空字符串片段会被忽略（如 filepath.Join(&quot;dir1&quot;, &quot;&quot;, &quot;dir2&quot;) → dir1/dir2）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准拼接：多个路径片段拼接为完整路径</span></span><br><span class="line">    p := filepath.Join(<span class="string">&quot;dir1&quot;</span>, <span class="string">&quot;dir2&quot;</span>, <span class="string">&quot;filename&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;p:&quot;</span>, p)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动清理多余分隔符（// 或 \\\ 会合并为一个）</span></span><br><span class="line">    fmt.Println(filepath.Join(<span class="string">&quot;dir1//&quot;</span>, <span class="string">&quot;filename&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自动处理 .. 路径跳转（.. 表示“上一级目录”）</span></span><br><span class="line">    fmt.Println(filepath.Join(<span class="string">&quot;dir1/../dir1&quot;</span>, <span class="string">&quot;filename&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取路径的“目录部分”（不含文件名）</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Dir(p):&quot;</span>, filepath.Dir(p))</span><br><span class="line">    <span class="comment">// 提取路径的“文件名部分”（不含目录）</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Base(p):&quot;</span>, filepath.Base(p))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断相对路径（无根目录开头）</span></span><br><span class="line">    fmt.Println(filepath.IsAbs(<span class="string">&quot;dir/file&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断绝对路径（Unix 以 / 开头，Windows 以 C:\ 等盘符开头）</span></span><br><span class="line">    fmt.Println(filepath.IsAbs(<span class="string">&quot;/dir/file&quot;</span>))</span><br><span class="line"></span><br><span class="line">    filename := <span class="string">&quot;config.json&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提取文件扩展名（含开头的 .）</span></span><br><span class="line">    ext := filepath.Ext(filename)</span><br><span class="line">    fmt.Println(ext) <span class="comment">// 输出：.json</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除扩展名（保留文件名主体）</span></span><br><span class="line">    fmt.Println(strings.TrimSuffix(filename, ext))</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    filepath.Rel(basepath, targpath string) (string, error)</span></span><br><span class="line"><span class="comment">    功能：计算从「基准路径 basepath」到「目标路径 targpath」的相对路径（即 “如何从 basepath 走到 targpath”）；</span></span><br><span class="line"><span class="comment">    参数要求：basepath 和 targpath 需是同一根目录下的路径（否则返回错误，如基准路径 /a 和目标路径 C:\b 无法计算相对路径）；</span></span><br><span class="line"><span class="comment">    关键逻辑：</span></span><br><span class="line"><span class="comment">       若目标路径是基准路径的子目录（如 a/b → a/b/t/file），直接返回子目录路径（t/file）；</span></span><br><span class="line"><span class="comment">       若目标路径与基准路径有共同父目录（如 a/b → a/c/t/file），用 ../ 跳转上一级目录（../c/t/file）；</span></span><br><span class="line"><span class="comment">       错误场景：基准路径或目标路径非法、两者无共同根目录（跨盘符），会返回非空错误（实际开发需处理）。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算从基准路径 &quot;a/b&quot; 到目标路径 &quot;a/b/t/file&quot; 的相对路径</span></span><br><span class="line">    rel, err := filepath.Rel(<span class="string">&quot;a/b&quot;</span>, <span class="string">&quot;a/b/t/file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(rel) <span class="comment">// 输出：t/file</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算从基准路径 &quot;a/b&quot; 到目标路径 &quot;a/c/t/file&quot; 的相对路径</span></span><br><span class="line">    rel, err = filepath.Rel(<span class="string">&quot;a/b&quot;</span>, <span class="string">&quot;a/c/t/file&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(rel) <span class="comment">// 输出：../c/t/file</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心函数总结</strong></p>
<table>
<thead>
<tr>
<th>场景需求</th>
<th>核心函数</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>路径拼接（跨平台）</td>
<td><code>filepath.Join(elem ...string)</code></td>
<td>自动处理分隔符、多余 <code>/</code>、<code>..</code> 跳转</td>
</tr>
<tr>
<td>提取目录部分</td>
<td><code>filepath.Dir(path string)</code></td>
<td>跨平台兼容，处理尾部 <code>/</code> 场景</td>
</tr>
<tr>
<td>提取文件名（含扩展名）</td>
<td><code>filepath.Base(path string)</code></td>
<td>区分文件和目录路径</td>
</tr>
<tr>
<td>判断绝对 &#x2F; 相对路径</td>
<td><code>filepath.IsAbs(path string)</code></td>
<td>适配 Unix&#x2F;Windows 绝对路径规则</td>
</tr>
<tr>
<td>提取文件扩展名</td>
<td><code>filepath.Ext(path string)</code></td>
<td>取最后一个 <code>.</code> 后的部分，含 <code>.</code></td>
</tr>
<tr>
<td>计算相对路径</td>
<td><code>filepath.Rel(base, target string)</code></td>
<td>需同一根目录，返回可直接使用的相对路径</td>
</tr>
</tbody></table>
<p><strong>关键注意点</strong></p>
<ol>
<li><strong>优先用 <code>filepath</code> 而非 <code>path</code> 包</strong>：<ul>
<li><code>path</code> 包：仅支持 <code>/</code> 分隔符（适合 URL 路径处理），不兼容 Windows；</li>
<li><code>filepath</code> 包：自动适配系统分隔符（推荐文件路径处理）；</li>
<li>错误示例：用 <code>path.Join</code> 处理 Windows 文件路径（<code>path.Join(&quot;C:&quot;, &quot;Users&quot;, &quot;file&quot;)</code> → <code>C:/Users/file</code>，Windows 系统可能无法识别）。</li>
</ul>
</li>
<li><strong>避免手动拼接路径字符串</strong>：<ul>
<li>错误写法：<code>dir + &quot;/&quot; + file</code>（Windows 下应是 <code>dir + &quot;\\&quot; + file</code>，跨平台会出错）；</li>
<li>正确写法：<code>filepath.Join(dir, file)</code>（自动适配分隔符）。</li>
</ul>
</li>
<li><strong><code>filepath.Ext</code> 的特殊情况</strong>：<ul>
<li>隐藏文件（如 <code>.bashrc</code>）的扩展名为 <code>.bashrc</code>（而非空）；</li>
<li>无扩展名文件（如 <code>README</code>）返回空字符串；</li>
<li>多扩展名文件（如 <code>archive.tar.gz</code>）返回最后一个扩展名（<code>.gz</code>）。</li>
</ul>
</li>
<li><strong><code>filepath.Rel</code> 的错误处理</strong>：<ul>
<li>若基准路径或目标路径是绝对路径，另一个是相对路径，需先转为统一格式（如用 <code>filepath.Abs()</code> 转为绝对路径）再计算；</li>
<li>跨盘符路径（如 Windows 下 <code>C:\a</code> 和 <code>D:\b</code>）无法计算相对路径，会返回错误，需提前判断。</li>
</ul>
</li>
<li><strong>路径规范化（补充用法）</strong>：<ul>
<li>若需将路径转为 “标准化格式”（清理多余 <code>/</code>、解析 <code>..</code>），可用 <code>filepath.Clean(path string)</code>（<code>filepath.Join</code> 内部已调用此函数）；</li>
<li>示例：<code>filepath.Clean(&quot;dir1//../dir2/./file&quot;)</code> → <code>dir2/file</code>。</li>
</ul>
</li>
</ol>
<h2 id="24-目录"><a href="#24-目录" class="headerlink" title="24.目录"></a>24.目录</h2><p><code>os</code> 包负责目录的基础操作（创建、删除、切换、读取），<code>filepath.Walk</code> 负责目录的递归遍历，配合 <code>os.ReadDir</code> 可灵活获取目录下的文件 &#x2F; 子目录信息，<code>defer os.RemoveAll</code> 是目录操作后清理资源的标准写法。</p>
<p><strong>核心目录操作 API：</strong></p>
<ul>
<li>目录创建：<code>os.Mkdir</code>（单层）、<code>os.MkdirAll</code>（多层，递归创建）；</li>
<li>目录删除：<code>os.RemoveAll</code>（递归删除目录及所有内容，慎用！）；</li>
<li>目录读取：<code>os.ReadDir</code>（获取目录下的所有文件 &#x2F; 子目录条目）；</li>
<li>工作目录切换：<code>os.Chdir</code>（切换当前程序的工作目录，类似 <code>cd</code> 命令）；</li>
<li>递归遍历：<code>filepath.Walk</code>（深度优先遍历目录下的所有文件 &#x2F; 子目录）；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkDir</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建单层目录：os.Mkdir(name string, perm os.FileMode) error</span></span><br><span class="line">    <span class="comment">//   - 功能：创建单个目录（父目录必须已存在，否则报错）；</span></span><br><span class="line">    <span class="comment">//   - 参数：&quot;subdir&quot; 是目录名，0755 是目录权限（Unix 下 rwxr-xr-x，Windows 忽略）；</span></span><br><span class="line">    err := os.Mkdir(<span class="string">&quot;subdir&quot;</span>, <span class="number">0755</span>)</span><br><span class="line">    checkDir(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  延迟删除目录：程序结束时，递归删除 &quot;subdir&quot; 及所有子目录/文件（避免残留）</span></span><br><span class="line">    <span class="comment">//   - 关键：os.RemoveAll 是递归删除，慎用！删除后无法恢复；</span></span><br><span class="line">    <span class="keyword">defer</span> os.RemoveAll(<span class="string">&quot;subdir&quot;</span>)</span><br><span class="line"></span><br><span class="line">    createEmptyFile := <span class="function"><span class="keyword">func</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">       d := []<span class="type">byte</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line">       <span class="comment">// os.WriteFile：创建文件（无则创建，有则覆盖），写入空字节，权限 0644；</span></span><br><span class="line">       check(os.WriteFile(name, d, <span class="number">0644</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEmptyFile(<span class="string">&quot;subdir/file1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建多层目录：os.MkdirAll(path string, perm os.FileMode) error</span></span><br><span class="line">    <span class="comment">//   - 功能：递归创建多层目录（父目录不存在则自动创建，类似 mkdir -p）；</span></span><br><span class="line">    <span class="comment">//   - 示例：创建 &quot;subdir/parent/child&quot;，即使 parent 和 child 都不存在也能成功；</span></span><br><span class="line">    err = os.MkdirAll(<span class="string">&quot;subdir/parent/child&quot;</span>, <span class="number">0755</span>)</span><br><span class="line">    checkDir(err)</span><br><span class="line"></span><br><span class="line">    createEmptyFile(<span class="string">&quot;subdir/parent/file2&quot;</span>)</span><br><span class="line">    createEmptyFile(<span class="string">&quot;subdir/parent/file3&quot;</span>)</span><br><span class="line">    createEmptyFile(<span class="string">&quot;subdir/parent/child/file4&quot;</span>)</span><br><span class="line"></span><br><span class="line">    c, err := os.ReadDir(<span class="string">&quot;subdir/parent&quot;</span>)</span><br><span class="line">    checkDir(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Listing subdir/parent&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, entry := <span class="keyword">range</span> c &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot; &quot;</span>, entry.Name(), entry.IsDir())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    err = os.Chdir(<span class="string">&quot;subdir/parent/child&quot;</span>)</span><br><span class="line">    checkDir(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取目录：os.ReadDir(name string) ([]os.DirEntry, error)</span></span><br><span class="line">    <span class="comment">//   - 功能：获取目录下的所有条目（文件+子目录），不递归；</span></span><br><span class="line">    <span class="comment">//   - 返回值：[]os.DirEntry 切片，每个元素包含条目名称和类型（文件/目录）；</span></span><br><span class="line">    c, err = os.ReadDir(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    checkDir(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Listing subdir/parent/child&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> _, entry := <span class="keyword">range</span> c &#123;</span><br><span class="line">       fmt.Println(<span class="string">&quot; &quot;</span>, entry.Name(), entry.IsDir())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换工作目录：os.Chdir(dir string) error</span></span><br><span class="line">    <span class="comment">//   - 功能：切换当前程序的工作目录（类似终端的 cd 命令）；</span></span><br><span class="line">    <span class="comment">//   - 示例：切换到 &quot;subdir/parent/child&quot;，后续的相对路径都基于此目录；</span></span><br><span class="line">    err = os.Chdir(<span class="string">&quot;../../..&quot;</span>)</span><br><span class="line">    checkDir(err)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归遍历目录：filepath.Walk(root string, walkFn WalkFunc) error</span></span><br><span class="line">    <span class="comment">//   - 功能：深度优先遍历 root 目录下的所有文件和子目录（包括 root 本身）；</span></span><br><span class="line">    <span class="comment">//   - 参数：</span></span><br><span class="line">    <span class="comment">//     - root：要遍历的根目录（&quot;subdir&quot;）；</span></span><br><span class="line">    <span class="comment">//     - walkFn：遍历回调函数（每个条目都会调用一次，参数为条目路径、信息、错误）；</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Visiting subdir&quot;</span>)</span><br><span class="line">    err = filepath.Walk(<span class="string">&quot;subdir&quot;</span>, visit)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">visit</span><span class="params">(p <span class="type">string</span>, info os.FileInfo, err <span class="type">error</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot; &quot;</span>, p, info.IsDir())</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>核心函数总结</strong></p>
<table>
<thead>
<tr>
<th>目录操作场景</th>
<th>核心函数</th>
<th>关键特点</th>
</tr>
</thead>
<tbody><tr>
<td>创建单层目录</td>
<td><code>os.Mkdir(name, perm)</code></td>
<td>父目录必须存在，仅创建一层</td>
</tr>
<tr>
<td>创建多层目录</td>
<td><code>os.MkdirAll(path, perm)</code></td>
<td>递归创建，父目录不存在则自动创建</td>
</tr>
<tr>
<td>删除目录（含内容）</td>
<td><code>os.RemoveAll(path)</code></td>
<td>递归删除，不可逆，慎用！</td>
</tr>
<tr>
<td>读取目录条目（非递归）</td>
<td><code>os.ReadDir(name)</code></td>
<td>返回 [] os.DirEntry，包含名称和类型</td>
</tr>
<tr>
<td>切换工作目录</td>
<td><code>os.Chdir(dir)</code></td>
<td>全局生效，需记得切换回原目录</td>
</tr>
<tr>
<td>递归遍历目录</td>
<td><code>filepath.Walk(root, walkFn)</code></td>
<td>深度优先，回调函数处理每个条目</td>
</tr>
<tr>
<td>获取当前工作目录</td>
<td><code>os.Getwd()</code></td>
<td>返回当前程序的工作目录路径</td>
</tr>
</tbody></table>
<h2 id="25-临时文件和目录"><a href="#25-临时文件和目录" class="headerlink" title="25.临时文件和目录"></a>25.临时文件和目录</h2><p>Go 中创建临时文件 &#x2F; 目录优先使用 <code>os.CreateTemp</code>（临时文件）和 <code>os.MkdirTemp</code>（临时目录），两者会自动生成唯一名称（避免冲突）、默认创建在系统临时目录，配合 <code>defer</code> 可确保程序结束后自动清理，避免临时资源残留。</p>
<p><strong>核心概念</strong></p>
<ol>
<li><strong>临时文件 &#x2F; 目录的核心特性：</strong><ul>
<li>自动唯一命名：生成的文件名 &#x2F; 目录名带随机后缀（如 <code>sample239465123</code>），避免多进程 &#x2F; 多实例冲突；</li>
<li>系统默认路径：默认创建在系统临时目录（Unix：<code>/tmp</code>，Windows：<code>C:\Users\用户名\AppData\Local\Temp</code>）；</li>
<li>自动清理：必须手动删除或用 <code>defer</code> 延迟删除（否则会残留）；</li>
</ul>
</li>
<li><strong>核心函数：</strong><ul>
<li><code>os.CreateTemp(dir string, prefix string) (*os.File, error)</code>：创建临时文件；</li>
<li><code>os.MkdirTemp(dir string, prefix string) (string, error)</code>：创建临时目录；</li>
<li><code>os.Remove(path string)</code>：删除文件（临时文件用）；</li>
<li><code>os.RemoveAll(path string)</code>：递归删除目录及内容（临时目录用）。</li>
</ul>
</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;path/filepath&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkTmp</span><span class="params">(e <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    f, err := os.CreateTemp(<span class="string">&quot;&quot;</span>, <span class="string">&quot;sample&quot;</span>)</span><br><span class="line">    checkTmp(err)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Temp file name:&quot;</span>, f.Name())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> os.Remove(f.Name())</span><br><span class="line"></span><br><span class="line">    _, err = f.Write([]<span class="type">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">    checkTmp(err)</span><br><span class="line"></span><br><span class="line">    dname, err := os.MkdirTemp(<span class="string">&quot;&quot;</span>, <span class="string">&quot;sampledir&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Temp dir name:&quot;</span>, dname)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> os.RemoveAll(dname)</span><br><span class="line"></span><br><span class="line">    fname := filepath.Join(dname, <span class="string">&quot;file1&quot;</span>)</span><br><span class="line">    err = os.WriteFile(fname, []<span class="type">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, <span class="number">0666</span>)</span><br><span class="line">    checkTmp(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键注意点</strong></p>
<ol>
<li><strong>必须手动清理临时资源</strong>：<ul>
<li><code>CreateTemp</code>&#x2F;<code>MkdirTemp</code> 不会自动删除临时文件 &#x2F; 目录，程序结束后会残留（占用磁盘空间）；</li>
<li>标准做法：创建后立即用 <code>defer</code> 延迟删除（如 <code>defer os.Remove(f.Name())</code>），确保无论程序正常结束还是报错，都会清理。</li>
</ul>
</li>
<li><strong>清理函数的选择</strong>：<ul>
<li>临时文件：用 <code>os.Remove(path)</code>（删除单个文件，高效）；</li>
<li>临时目录：用 <code>os.RemoveAll(path)</code>（递归删除目录及所有内容，即使目录非空）；</li>
</ul>
</li>
<li><strong>文件名 &#x2F; 目录名的唯一性</strong>：<ul>
<li>前缀 <code>prefix</code> 仅用于标识，随机后缀是确保唯一性的核心（避免多进程同时创建同名临时资源）；</li>
<li>无需手动设计唯一名称，依赖系统生成即可。</li>
</ul>
</li>
<li><strong>指定自定义临时目录</strong>：<ul>
<li>若需将临时文件 &#x2F; 目录创建在自定义目录（如 <code>./app/tmp</code>），需确保该目录已存在（可先用 <code>os.MkdirAll</code> 创建）；</li>
<li>示例：<code>os.CreateTemp(&quot;./app/tmp&quot;, &quot;sample&quot;)</code> → 需先 <code>os.MkdirAll(&quot;./app/tmp&quot;, 0755)</code>。</li>
</ul>
</li>
<li><strong>临时文件的权限控制</strong>：<ul>
<li>默认权限仅当前用户可访问（Unix 0600&#x2F;0700），若需其他用户访问，可在创建后用 <code>os.Chmod</code> 修改权限（如 <code>os.Chmod(f.Name(), 0644)</code>）；</li>
<li>敏感临时数据（如密码、密钥）建议保持默认权限，避免泄露。</li>
</ul>
</li>
</ol>
<h2 id="26-单元测试和基准测试"><a href="#26-单元测试和基准测试" class="headerlink" title="26.单元测试和基准测试"></a>26.单元测试和基准测试</h2><p><strong>核心概念与规范</strong></p>
<p><strong>1. 测试文件与函数规范（Go 内置约定，必须遵守）</strong></p>
<table>
<thead>
<tr>
<th>测试类型</th>
<th>文件命名规则</th>
<th>函数名规则</th>
<th>函数参数</th>
<th>核心用途</th>
</tr>
</thead>
<tbody><tr>
<td>单元测试</td>
<td>以 <code>_test.go</code> 结尾</td>
<td>以 <code>Test</code> 开头（首字母大写）</td>
<td><code>(t *testing.T)</code></td>
<td>验证函数逻辑是否正确</td>
</tr>
<tr>
<td>基准测试</td>
<td>以 <code>_test.go</code> 结尾</td>
<td>以 <code>Benchmark</code> 开头</td>
<td><code>(b *testing.B)</code></td>
<td>测量函数执行性能</td>
</tr>
<tr>
<td>注意</td>
<td>测试文件需与被测试文件在同一包下</td>
<td>函数名后必须跟大写字母（如 <code>TestIntMin</code> 而非 <code>Testintmin</code>）</td>
<td><code>*testing.T</code>&#x2F;<code>*testing.B</code> 是测试框架的核心对象，用于报告错误、控制测试流程</td>
<td></td>
</tr>
</tbody></table>
<p><strong>2.核心工具命令（终端执行）</strong></p>
<ul>
<li>执行单元测试：<code>go test -v</code>（<code>-v</code> 显示详细测试日志，不加则只显示是否通过）；</li>
<li>执行基准测试：<code>go test -bench=.</code>（<code>.</code> 表示运行所有基准测试，<code>-benchmem</code> 可显示内存分配情况）；</li>
<li>同时执行单元测试和基准测试：<code>go test -v -bench=.</code>。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">IntMin</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">       <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIntMinBasic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    ans := IntMin(<span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line">    <span class="keyword">if</span> ans != <span class="number">-2</span> &#123;</span><br><span class="line"></span><br><span class="line">       t.Errorf(<span class="string">&quot;IntMin(2, -2) = %d; want -2&quot;</span>, ans)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestIntMinTableDriven</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> tests = []<span class="keyword">struct</span> &#123;</span><br><span class="line">       a, b <span class="type">int</span></span><br><span class="line">       want <span class="type">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">       &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">       &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">       &#123;<span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>&#125;,</span><br><span class="line">       &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">       &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;</span><br><span class="line"></span><br><span class="line">       testname := fmt.Sprintf(<span class="string">&quot;%d,%d&quot;</span>, tt.a, tt.b)</span><br><span class="line">       t.Run(testname, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">          ans := IntMin(tt.a, tt.b)</span><br><span class="line">          <span class="keyword">if</span> ans != tt.want &#123;</span><br><span class="line">             t.Errorf(<span class="string">&quot;got %d, want %d&quot;</span>, ans, tt.want)</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkIntMin</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">       IntMin(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>测试命令常用参数</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-v</code></td>
<td>显示详细测试日志（单元测试）</td>
<td><code>go test -v</code></td>
</tr>
<tr>
<td><code>-run 正则</code></td>
<td>只执行匹配的单元测试（支持正则）</td>
<td><code>go test -run TestIntMinTableDriven</code></td>
</tr>
<tr>
<td><code>-bench 正则</code></td>
<td>只执行匹配的基准测试</td>
<td><code>go test -bench=IntMin</code></td>
</tr>
<tr>
<td><code>-benchmem</code></td>
<td>显示基准测试的内存分配情况</td>
<td><code>go test -bench=. -benchmem</code></td>
</tr>
<tr>
<td><code>-count n</code></td>
<td>执行 n 次测试（取平均值，提高稳定性）</td>
<td><code>go test -bench=. -count 5</code></td>
</tr>
<tr>
<td><code>-cpu n</code></td>
<td>指定测试使用的 CPU 核心数</td>
<td><code>go test -bench=. -cpu 4</code></td>
</tr>
</tbody></table>
<h2 id="27-HTTP-客户端"><a href="#27-HTTP-客户端" class="headerlink" title="27.HTTP 客户端"></a>27.HTTP 客户端</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;bufio&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 发送 GET 请求：http.Get(url) → 核心 API，内部已封装默认的 HTTP 客户端</span></span><br><span class="line">    <span class="comment">//   - 参数：目标 URL（必须带协议头，如 http:// 或 https://，否则报错）；</span></span><br><span class="line">    <span class="comment">//   - 返回值：</span></span><br><span class="line">    <span class="comment">//     - *http.Response：响应对象（包含状态、头、体等所有响应信息）；</span></span><br><span class="line">    <span class="comment">//     - error：请求过程中的错误（如网络不通、URL 格式错误、超时等）；</span></span><br><span class="line">    resp, err := http.Get(<span class="string">&quot;http://gobyexample.com&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 延迟关闭响应体：核心！避免连接泄漏（必须写，且要在检查 err 之后）</span></span><br><span class="line">    <span class="comment">//   - 原因：resp.Body 是 TCP 连接的一部分，若不关闭，连接会一直占用，直到达到最大连接数导致后续请求失败；</span></span><br><span class="line">    <span class="comment">//   - 位置：必须在 err 检查之后（若请求失败，resp 为 nil，调用 resp.Body.Close() 会 panic）；</span></span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response status:&quot;</span>, resp.Status)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建扫描器：从 resp.Body 中逐行读取响应体（resp.Body 实现 io.Reader 接口，可被 scanner 读取）</span></span><br><span class="line">    scanner := bufio.NewScanner(resp.Body)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; scanner.Scan() &amp;&amp; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">       <span class="comment">// scanner.Text() → 获取当前行的文本内容（已去除末尾的换行符）</span></span><br><span class="line">       fmt.Println(scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := scanner.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">       <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-HTTP-服务端"><a href="#28-HTTP-服务端" class="headerlink" title="28.HTTP 服务端"></a>28.HTTP 服务端</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hello</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;hello\n&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">headers</span><span class="params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name, headers := <span class="keyword">range</span> req.Header &#123;</span><br><span class="line">       <span class="keyword">for</span> _, h := <span class="keyword">range</span> headers &#123;</span><br><span class="line">          fmt.Fprintf(w, <span class="string">&quot;%v: %v\n&quot;</span>, name, h)</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册路由：将 URL 路径 &quot;/hello&quot; 与 hello 处理函数绑定</span></span><br><span class="line">    <span class="comment">// 当客户端访问 http://localhost:8090/hello 时，会调用 hello 函数</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, hello)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册路由：将 URL 路径 &quot;/headers&quot; 与 headers 处理函数绑定</span></span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/headers&quot;</span>, headers)</span><br><span class="line"></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8090&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/12/GoByExample(down)/" data-id="cuidb2l0QpSC3z1aD4YHm-S0i" data-title="Go语言基础学习（下）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go%E5%AD%A6%E4%B9%A0/" rel="tag">Go学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2025/11/26/5-HTTP%E8%AE%A4%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          #5.HTTP认证中间件
        
      </div>
    </a>
  
  
    <a href="/2025/11/11/GoByExample(mid)/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">Go语言基础学习（中）</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/">算法刷题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go-Interview-Practice/" rel="tag">Go Interview Practice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go%E5%AD%A6%E4%B9%A0/" rel="tag">Go学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode-Top100/" rel="tag">LeetCode Top100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go-Interview-Practice/" style="font-size: 17.5px;">Go Interview Practice</a> <a href="/tags/Go%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">Go学习</a> <a href="/tags/LeetCode-Top100/" style="font-size: 20px;">LeetCode Top100</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.5px;">双指针</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 15px;">哈希</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">十一月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/11/28/10-%E5%A4%9A%E6%80%81%E5%BD%A2%E7%8A%B6%E8%AE%A1%E7%AE%97%E5%99%A8/">#10.多态形状计算器</a>
          </li>
        
          <li>
            <a href="/2025/11/28/13-%E8%BF%9B%E8%A1%8C%20SQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">#13.进行 SQL 数据库操作</a>
          </li>
        
          <li>
            <a href="/2025/11/26/4-%E5%B9%B6%E5%8F%91BFS%E6%9F%A5%E8%AF%A2/">#4.并发BFS查询</a>
          </li>
        
          <li>
            <a href="/2025/11/26/5-HTTP%E8%AE%A4%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6/">#5.HTTP认证中间件</a>
          </li>
        
          <li>
            <a href="/2025/11/12/GoByExample(down)/">Go语言基础学习（下）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 zianCoderMan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>