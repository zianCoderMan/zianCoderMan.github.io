<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>zianCoderMan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="咦？这里有个CoderMan在Coding......">
<meta property="og:type" content="website">
<meta property="og:title" content="zianCoderMan">
<meta property="og:url" content="https://ziancoderman.github.io/index.html">
<meta property="og:site_name" content="zianCoderMan">
<meta property="og:description" content="咦？这里有个CoderMan在Coding......">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zianCoderMan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="zianCoderMan" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 8.1.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">zianCoderMan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://ziancoderman.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-10-多态形状计算器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/28/10-%E5%A4%9A%E6%80%81%E5%BD%A2%E7%8A%B6%E8%AE%A1%E7%AE%97%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-11-28T02:10:58.000Z" itemprop="datePublished">2025-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/28/10-%E5%A4%9A%E6%80%81%E5%BD%A2%E7%8A%B6%E8%AE%A1%E7%AE%97%E5%99%A8/">#10.多态形状计算器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>问题</strong></p>
<p>使用 Go 接口实现一个计算各种几何形状属性的系统。这项挑战的重点在于理解并正确实现 Go 的接口系统，以实现多态性。</p>
<p><strong>要求</strong></p>
<p>1.实现一个<code>Shape</code>包含以下方法的接口：</p>
<ul>
<li><code>Area() float64</code>计算图形的面积</li>
<li><code>Perimeter() float64</code>计算图形的周长（或圆周长）</li>
<li><code>String() string</code>返回形状的字符串表示形式（实现 fmt.Stringer）</li>
</ul>
<p>2.具体实现以下形式：</p>
<ul>
<li><code>Rectangle</code>：由宽度和高度定义</li>
<li><code>Circle</code>由半径定义</li>
<li><code>Triangle</code>由三条边定义（使用海伦公式计算面积）</li>
</ul>
<p>3.实施一个<code>ShapeCalculator</code>可以实现以下功能的方案：</p>
<ul>
<li>取任意形状并返回其属性</li>
<li>计算多个图形的总面积</li>
<li>从一组图形中找出面积最大的图形</li>
<li>按面积升序或降序对形状进行排序</li>
</ul>
<p><strong>解答</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package challenge10 contains the solution for Challenge 10.</span></span><br><span class="line"><span class="keyword">package</span> challenge10</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">// Add any necessary imports here</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shape interface defines methods that all shapes must implement</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">	Area() <span class="type">float64</span></span><br><span class="line">	Perimeter() <span class="type">float64</span></span><br><span class="line">	fmt.Stringer <span class="comment">// Includes String() string method</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle represents a four-sided shape with perpendicular sides</span></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Width  <span class="type">float64</span></span><br><span class="line">	Height <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRectangle creates a new Rectangle with validation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRectangle</span><span class="params">(width, height <span class="type">float64</span>)</span></span> (*Rectangle, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement validation and construction</span></span><br><span class="line">	<span class="keyword">if</span> width &lt;= <span class="number">0</span> || height &lt;= <span class="number">0</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>,errors.New(<span class="string">&quot;width and height must be positive&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Rectangle&#123;width,height&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area calculates the area of the rectangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement area calculation</span></span><br><span class="line">	<span class="keyword">return</span> r.Width * r.Height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perimeter calculates the perimeter of the rectangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement perimeter calculation</span></span><br><span class="line">	<span class="keyword">return</span> (r.Width + r.Height) * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String returns a string representation of the rectangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Rectangle)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement string representation</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Rectangle(width=%.2f, height=%.2f)&quot;</span>, r.Width, r.Height)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle represents a perfectly round shape</span></span><br><span class="line"><span class="keyword">type</span> Circle <span class="keyword">struct</span> &#123;</span><br><span class="line">	Radius <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCircle creates a new Circle with validation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCircle</span><span class="params">(radius <span class="type">float64</span>)</span></span> (*Circle, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement validation and construction</span></span><br><span class="line">	<span class="keyword">if</span> radius &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;radius must be positive&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Circle&#123;radius&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area calculates the area of the circle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement area calculation</span></span><br><span class="line">	<span class="keyword">return</span> math.Pi * math.Pow(c.Radius,<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perimeter calculates the circumference of the circle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement perimeter calculation</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * math.Pi * c.Radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String returns a string representation of the circle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Circle)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement string representation</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Circle(Radius = %.2f)&quot;</span>, c.Radius)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Triangle represents a three-sided polygon</span></span><br><span class="line"><span class="keyword">type</span> Triangle <span class="keyword">struct</span> &#123;</span><br><span class="line">	SideA <span class="type">float64</span></span><br><span class="line">	SideB <span class="type">float64</span></span><br><span class="line">	SideC <span class="type">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewTriangle creates a new Triangle with validation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTriangle</span><span class="params">(a, b, c <span class="type">float64</span>)</span></span> (*Triangle, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement validation and construction</span></span><br><span class="line">	<span class="comment">// 提前声明 err，避免作用域问题（原错误：err 仅在 if 内定义）</span></span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="comment">// 校验边长为正数</span></span><br><span class="line">	<span class="keyword">if</span> a &lt;= <span class="number">0</span> || b &lt;= <span class="number">0</span> || c &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;all sides must be positive&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> a + b &lt;= c || a + c &lt;= b || b + c &lt;= a&#123;</span><br><span class="line">		err = errors.New(<span class="string">&quot;sides do not satisfy triangle inequality&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;Triangle&#123;a,b,c&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Area calculates the area of the triangle using Heron&#x27;s formula</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> Area() <span class="type">float64</span> &#123;</span><br><span class="line">	p := (t.SideA + t.SideB + t.SideC) / <span class="number">2</span></span><br><span class="line">	<span class="comment">// 防护浮点数精度问题，避免根号内为负数</span></span><br><span class="line">	<span class="keyword">return</span> math.Sqrt(math.Max(<span class="number">0</span>, p*(p-t.SideA)*(p-t.SideB)*(p-t.SideC)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perimeter calculates the perimeter of the triangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> Perimeter() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement perimeter calculation</span></span><br><span class="line">	<span class="keyword">return</span> t.SideA + t.SideB + t.SideC</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String returns a string representation of the triangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement string representation</span></span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Triangle(sides=%.2f, %.2f, %.2f)&quot;</span>, t.SideA, t.SideB, t.SideC)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ShapeCalculator provides utility functions for shapes</span></span><br><span class="line"><span class="keyword">type</span> ShapeCalculator <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewShapeCalculator creates a new ShapeCalculator</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewShapeCalculator</span><span class="params">()</span></span> *ShapeCalculator &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement constructor</span></span><br><span class="line">	<span class="keyword">return</span> &amp;ShapeCalculator&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PrintProperties prints the properties of a shape</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShapeCalculator)</span></span> PrintProperties(s Shape) &#123;</span><br><span class="line">	<span class="keyword">if</span> s == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;nil shape&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;=== Shape Properties ===\n&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Type: %s\n&quot;</span>, s.String())       <span class="comment">// 调用指针接收者的 String()</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Area: %.2f\n&quot;</span>, s.Area())      <span class="comment">// 调用指针接收者的 Area()</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Perimeter: %.2f\n\n&quot;</span>, s.Perimeter()) <span class="comment">// 调用指针接收者的 Perimeter()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// TotalArea calculates the sum of areas of all shapes</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShapeCalculator)</span></span> TotalArea(shapes []Shape) <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement total area calculation</span></span><br><span class="line">	<span class="keyword">var</span> total <span class="type">float64</span></span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> shapes&#123;</span><br><span class="line">		total += s.Area()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> total</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LargestShape finds the shape with the largest area</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShapeCalculator)</span></span> LargestShape(shapes []Shape) Shape &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(shapes) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 空切片返回 nil，调用者需处理</span></span><br><span class="line">	&#125;</span><br><span class="line">	largest := shapes[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, s := <span class="keyword">range</span> shapes[<span class="number">1</span>:] &#123;</span><br><span class="line">		<span class="keyword">if</span> s.Area() &gt; largest.Area() &#123;</span><br><span class="line">			largest = s</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> largest <span class="comment">// 返回的是指针（满足 Shape 接口）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SortByArea sorts shapes by area in ascending or descending order</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShapeCalculator)</span></span> SortByArea(shapes []Shape, ascending <span class="type">bool</span>) []Shape &#123;</span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> Implement sorting shapes by </span></span><br><span class="line">	<span class="comment">// 拷贝切片，避免修改原切片（Shape 是接口类型，拷贝的是指针引用，不影响原数据）</span></span><br><span class="line">	sorted := <span class="built_in">make</span>([]Shape, <span class="built_in">len</span>(shapes))</span><br><span class="line">	<span class="built_in">copy</span>(sorted, shapes)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 排序逻辑：指针接收者调用 Area()</span></span><br><span class="line">	sort.Slice(sorted, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		areaI := sorted[i].Area()</span><br><span class="line">		areaJ := sorted[j].Area()</span><br><span class="line">		<span class="keyword">if</span> ascending &#123;</span><br><span class="line">			<span class="keyword">return</span> areaI &lt; areaJ</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> areaI &gt; areaJ </span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> sorted</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="对t-Triangle-a-b-c-的解析"><a href="#对t-Triangle-a-b-c-的解析" class="headerlink" title="对t := &amp;Triangle{a, b, c}的解析"></a>对<code>t := &amp;Triangle{a, b, c}</code>的解析</h2><p><code>&amp;</code> 是「取地址运算符」，作用于「值类型变量 &#x2F; 字面量」，返回该值的内存地址（指针类型）。这行代码等价于：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分步拆解（效果完全一致）</span></span><br><span class="line">temp := Triangle&#123;a, b, c&#125; <span class="comment">// 先创建值类型变量 temp（类型：Triangle）</span></span><br><span class="line">t := &amp;temp                 <span class="comment">// 取 temp 的地址，赋值给指针变量 t（类型：*Triangle）</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>内存分配</strong>：编译器会根据场景自动优化：如果 <code>t</code> 仅在函数内使用（短生命周期），则 <code>temp</code> 分配在<strong>栈上</strong>（高效）；如果 <code>t</code> 被返回（长生命周期，可能逃逸到函数外），则分配在<strong>堆上</strong>（由 GC 管理）。</li>
</ul>
<p><strong>错误写法：</strong><code>**&amp;t := Triangle{a, b, c}**</code></p>
<ul>
<li><strong>语法错误原因</strong>：Go 中变量声明的格式是 <code>变量名 := 表达式</code>，<code>变量名</code> 必须是「标识符」（如 <code>t</code>），而不能是「表达式」（如 <code>&amp;t</code>）。<code>&amp;t</code> 是「取变量 <code>t</code> 的地址」，本身是一个「指针表达式」，不能作为「变量名」使用 —— 就像不能写 <code>123 := 456</code> 一样，完全违反语法规则。</li>
</ul>
<p><strong>常见误区澄清</strong></p>
<p><strong>误区 1：「取地址只能作用于变量，不能作用于字面量」？</strong></p>
<ul>
<li>错误！Go 允许直接对「结构体字面量」取地址（如 <code>&amp;Triangle{a, b, c}</code>），编译器会自动优化为「创建值 + 取地址」，无需手动声明中间变量。</li>
</ul>
<p><strong>误区 2：「指针变量必须用</strong> <code>**new()**</code> <strong>函数创建」？</strong></p>
<ul>
<li>错误！<code>new(T)</code> 是另一种创建指针的方式（如 <code>t := new(Triangle)</code>），但它会初始化结构体的「零值」（如 <code>SideA=0, SideB=0, SideC=0</code>），后续需要手动赋值。而 <code>&amp;Triangle{a, b, c}</code> 可以直接初始化字段，更灵活高效，是结构体指针创建的首选方式。</li>
</ul>
<p><strong>误区 3：「栈分配比堆分配好，必须手动控制」？</strong></p>
<ul>
<li>错误！Go 编译器的「逃逸分析」会自动优化内存分配：短生命周期的变量分配在栈上（无 GC 开销），长生命周期的变量分配在堆上（由 GC 管理）。开发者无需手动干预，只需关注「变量类型是否符合需求」（值 &#x2F; 指针）即可。</li>
</ul>
<h2 id="方法接收者的值类型和指针类型的区别"><a href="#方法接收者的值类型和指针类型的区别" class="headerlink" title="方法接收者的值类型和指针类型的区别"></a>方法接收者的值类型和指针类型的区别</h2><p>方法接收者是方法的「隐含参数」，用于绑定方法到具体类型。两种接收者的本质区别是：</p>
<ul>
<li><strong>值类型接收者</strong>：方法接收的是原对象的「副本」（值拷贝），方法内修改的是副本，不影响原对象。</li>
<li><strong>指针类型接收者</strong>：方法接收的是原对象的「内存地址」（指针），方法内通过指针修改的是原对象本身。</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比维度</strong></th>
<th><strong>值类型接收者</strong><strong>（</strong><code>**func (t Triangle) Area()**</code><strong>）</strong></th>
<th><strong>指针类型接收者</strong><strong>（</strong><code>**func (t \*Triangle) Area()**</code><strong>）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>修改原对象</strong></td>
<td>不能：修改的是副本，原对象不变</td>
<td>能：通过指针直接操作原对象</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>大：每次调用方法都会拷贝整个结构体（结构体越大，开销越大）</td>
<td>小：仅拷贝指针（8 字节 &#x2F; 64 位系统，与结构体大小无关）</td>
</tr>
<tr>
<td><strong>接口实现</strong></td>
<td>结构体「值」和「指针」都能实现接口（值接收者会自动适配指针）</td>
<td>仅结构体「指针」能实现接口（值无法自动适配指针）</td>
</tr>
<tr>
<td><strong>nil 接收者</strong></td>
<td>不能接收 nil（值类型无法为 nil）</td>
<td>可以接收 nil（指针类型允许为 nil，需手动处理避免 panic）</td>
</tr>
<tr>
<td><strong>方法集</strong></td>
<td>仅包含「值接收者方法」（值类型和指针类型都能调用）</td>
<td>包含「指针接收者方法」+「值接收者方法」（指针类型能调用所有方法）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>结构体小、无修改需求（如纯计算：面积 &#x2F; 周长）</td>
<td>结构体大、需修改原对象、实现接口（如你的项目）</td>
</tr>
</tbody></table>
<p><strong>1. 修改原对象：指针接收者的核心优势</strong></p>
<p>假设需要给 <code>Triangle</code> 加一个「修改边长」的方法，两种接收者的差异：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 值类型接收者：修改无效（仅修改副本）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Triangle)</span></span> SetSideA(newA <span class="type">float64</span>) &#123;</span><br><span class="line">    t.SideA = newA <span class="comment">// 修改的是副本的 SideA，原对象不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 指针类型接收者：修改有效（直接操作原对象）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Triangle)</span></span> SetSideA(newA <span class="type">float64</span>) &#123;</span><br><span class="line">    t.SideA = newA <span class="comment">// 通过指针修改原对象的 SideA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tri := &amp;Triangle&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125; <span class="comment">// 指针类型</span></span><br><span class="line">    tri.SetSideA(<span class="number">10</span>)         <span class="comment">// 调用指针接收者方法</span></span><br><span class="line">    fmt.Println(tri.SideA)   <span class="comment">// 输出 10（原对象已修改）</span></span><br><span class="line"></span><br><span class="line">    tri2 := Triangle&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;  <span class="comment">// 值类型</span></span><br><span class="line">    tri2.SetSideA(<span class="number">10</span>)        <span class="comment">// 调用值接收者方法</span></span><br><span class="line">    fmt.Println(tri2.SideA)  <span class="comment">// 输出 3（原对象未修改）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**2.**<strong>内存开销：指针接收者更高效（尤其结构体较大时）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大结构体（假设包含 1000 个顶点）</span></span><br><span class="line"><span class="keyword">type</span> Polygon <span class="keyword">struct</span> &#123;</span><br><span class="line">    Vertices []<span class="type">float64</span> <span class="comment">// 8000 字节（1000 个 float64）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值类型接收者：每次调用方法拷贝 8000 字节，开销巨大</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Polygon)</span></span> Perimeter() <span class="type">float64</span> &#123; <span class="comment">/* 计算逻辑 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针类型接收者：仅拷贝 8 字节指针，开销忽略不计</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Polygon)</span></span> Perimeter() <span class="type">float64</span> &#123; <span class="comment">/* 计算逻辑 */</span> &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/28/10-%E5%A4%9A%E6%80%81%E5%BD%A2%E7%8A%B6%E8%AE%A1%E7%AE%97%E5%99%A8/" data-id="cuidwJoEsghP11DEl_UhPjRSj" data-title="#10.多态形状计算器" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go-Interview-Practice/" rel="tag">Go Interview Practice</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-13-进行 SQL 数据库操作" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/28/13-%E8%BF%9B%E8%A1%8C%20SQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/" class="article-date">
  <time class="dt-published" datetime="2025-11-28T02:10:58.000Z" itemprop="datePublished">2025-11-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/28/13-%E8%BF%9B%E8%A1%8C%20SQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">#13.进行 SQL 数据库操作</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Learnings"><a href="#Learnings" class="headerlink" title="Learnings"></a>Learnings</h2><p>Go 通过其标准包为 SQL 数据库提供了出色的支持<code>database/sql</code>。本次挑战的重点是使用 SQLite 实现 CRUD 操作，但其中的概念也适用于其他 SQL 数据库，例如 MySQL、PostgreSQL 等。</p>
<h3 id="数据库-SQL-包"><a href="#数据库-SQL-包" class="headerlink" title="数据库&#x2F;SQL 包"></a>数据库&#x2F;SQL 包</h3><p>该<code>database/sql</code>软件包提供了一个围绕 SQL（或类 SQL）数据库的通用接口。它：</p>
<ul>
<li>管理连接池</li>
<li>处理事务</li>
<li>提供预编译</li>
<li>提供其他数据库的驱动</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">    _ <span class="string">&quot;github.com/mattn/go-sqlite3&quot;</span> <span class="comment">// Note the underscore import</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用下划线（_）作为导入包的前缀表示仅仅为了副作用而导入（在本例中，注册数据库驱动程序）。</p>
<h3 id="打开数据库连接"><a href="#打开数据库连接" class="headerlink" title="打开数据库连接"></a>打开数据库连接</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql.open(驱动名,数据源dsn)(*DB,err)</span></span><br><span class="line">db, err := sql.Open(<span class="string">&quot;sqlite3&quot;</span>, <span class="string">&quot;path/to/database.db&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test the connection</span></span><br><span class="line"><span class="keyword">if</span> err = db.Ping(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> db, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>该<code>sql.Open()</code>函数实际上并不会主动建立数据库连接。只有当你调用类似 get() 的方法<code>Ping()</code>或执行查询时，才会建立连接。</p>
<h3 id="执行简单查询"><a href="#执行简单查询" class="headerlink" title="执行简单查询"></a>执行简单查询</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">result, err := db.Exec(</span><br><span class="line">    <span class="string">&quot;CREATE TABLE IF NOT EXISTS products (id INTEGER PRIMARY KEY, name TEXT, price REAL, quantity INTEGER, category TEXT)&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>INSERT</code>操作，可以检索最后插入的 ID：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">result, err := db.Exec(</span><br><span class="line">    <span class="string">&quot;INSERT INTO products (name, price, quantity, category) VALUES (?, ?, ?, ?)&quot;</span>,</span><br><span class="line">    product.Name, product.Price, product.Quantity, product.Category</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the ID of the inserted row</span></span><br><span class="line">id, err := result.LastInsertId()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">product.ID = id</span><br></pre></td></tr></table></figure>

<h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p>要查询和检索数据，多行数据<code>db.Query()</code>、单行数据<code>db.QueryRow()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For multiple rows</span></span><br><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT id, name, price, quantity, category FROM products WHERE category = ?&quot;</span>, category)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> rows.Close() <span class="comment">// Always close rows when done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> products []*Product</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">    p := &amp;Product&#123;&#125;</span><br><span class="line">    err := rows.Scan(&amp;p.ID, &amp;p.Name, &amp;p.Price, &amp;p.Quantity, &amp;p.Category)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    products = <span class="built_in">append</span>(products, p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for errors from iterating over rows</span></span><br><span class="line"><span class="keyword">if</span> err = rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> products, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>对于单行，请使用<code>QueryRow()</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">row := db.QueryRow(<span class="string">&quot;SELECT id, name, price, quantity, category FROM products WHERE id = ?&quot;</span>, id)</span><br><span class="line"></span><br><span class="line">p := &amp;Product&#123;&#125;</span><br><span class="line">err := row.Scan(&amp;p.ID, &amp;p.Name, &amp;p.Price, &amp;p.Quantity, &amp;p.Category)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;product with ID %d not found&quot;</span>, id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p, <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="提供预编译"><a href="#提供预编译" class="headerlink" title="提供预编译"></a>提供预编译</h3><p>对于需要多次执行的查询，可以使用预处理语句来提高性能：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">stmt, err := db.Prepare(<span class="string">&quot;UPDATE products SET quantity = ? WHERE id = ?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id, quantity := <span class="keyword">range</span> updates &#123;</span><br><span class="line">    _, err := stmt.Exec(quantity, id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务确保一组操作要么全部成功，要么全部失败：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin a transaction</span></span><br><span class="line">tx, err := db.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Rollback() <span class="comment">// Rollback on error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">stmt, err := tx.Prepare(<span class="string">&quot;UPDATE products SET quantity = ? WHERE id = ?&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> id, quantity := <span class="keyword">range</span> updates &#123;</span><br><span class="line">    result, err := stmt.Exec(quantity, id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取更新的条数</span></span><br><span class="line">    rowsAffected, err := result.RowsAffected()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> rowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;product with ID %d not found&quot;</span>, id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Commit the transaction</span></span><br><span class="line"><span class="keyword">return</span> tx.Commit()</span><br></pre></td></tr></table></figure>

<h3 id="参数绑定和-SQL-注入防护"><a href="#参数绑定和-SQL-注入防护" class="headerlink" title="参数绑定和 SQL 注入防护"></a>参数绑定和 SQL 注入防护</h3><p>为防止 SQL 注入，请始终使用参数绑定而不是字符串拼接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DON&#x27;T DO THIS - vulnerable to SQL injection</span></span><br><span class="line">query := fmt.Sprintf(<span class="string">&quot;SELECT * FROM products WHERE category = &#x27;%s&#x27;&quot;</span>, category)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DO THIS - uses parameter binding</span></span><br><span class="line">rows, err := db.Query(<span class="string">&quot;SELECT * FROM products WHERE category = ?&quot;</span>, category)</span><br></pre></td></tr></table></figure>

<p>不同的数据库驱动程序使用不同的占位符样式：</p>
<ul>
<li>SQLite、MySQL：<code>?</code></li>
<li>PostgreSQL：<code>$1</code>，，<code>$2</code>等等。</li>
<li>甲骨文：<code>:name</code></li>
</ul>
<h3 id="处理空值"><a href="#处理空值" class="headerlink" title="处理空值"></a>处理空值</h3><p>SQL 数据库可以包含 NULL 值。Go 语言的<code>database/sql</code>包中提供了特殊的类型来处理这些值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;database/sql&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID       <span class="type">int64</span></span><br><span class="line">    Name     <span class="type">string</span></span><br><span class="line">    Price    <span class="type">float64</span></span><br><span class="line">    Quantity <span class="type">int</span></span><br><span class="line">    Category sql.NullString <span class="comment">// Can be NULL</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// When scanning</span></span><br><span class="line"><span class="keyword">var</span> category sql.NullString</span><br><span class="line">err := row.Scan(&amp;id, &amp;name, &amp;price, &amp;quantity, &amp;category)</span><br><span class="line"></span><br><span class="line"><span class="comment">// When using</span></span><br><span class="line"><span class="keyword">if</span> category.Valid &#123;</span><br><span class="line">    fmt.Println(category.String)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Category is NULL&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>需要检查以下几种错误类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">    <span class="comment">// No rows returned (not necessarily an error)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;product not found&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for unique constraint violation</span></span><br><span class="line"><span class="keyword">if</span> strings.Contains(err.Error(), <span class="string">&quot;UNIQUE constraint failed&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;product with that name already exists&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>该<code>database/sql</code>软件包会自动处理连接池。您可以控制连接池的行为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.SetMaxOpenConns(<span class="number">25</span>)  <span class="comment">// Maximum number of open connections</span></span><br><span class="line">db.SetMaxIdleConns(<span class="number">25</span>)  <span class="comment">// Maximum number of idle connections</span></span><br><span class="line">db.SetConnMaxLifetime(<span class="number">5</span> * time.Minute) <span class="comment">// Maximum amount of time a connection may be reused</span></span><br></pre></td></tr></table></figure>

<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>问题</strong></p>
<p>在这个挑战中，你将使用 Go 和 SQL 实现一个产品库存系统。你将创建与 SQLite 数据库交互的函数，以对产品执行 CRUD 操作（创建、读取、更新、删除）。</p>
<p><strong>要求</strong></p>
<ol>
<li>创建一个包含<code>products</code>表的 SQLite 数据库</li>
<li>实现以下功能：</li>
</ol>
<ul>
<li><code>CreateProduct</code>- 向数据库添加新产品</li>
<li><code>GetProduct</code>- 通过 ID 检索产品</li>
<li><code>UpdateProduct</code>- 更新产品详情</li>
<li><code>DeleteProduct</code>- 移除产品</li>
<li><code>ListProducts</code>- 列出所有产品，并提供可选筛选功能</li>
</ul>
<ol>
<li>确保数据库操作中的错误处理得当</li>
<li>实现对修改多个记录的操作的事务支持</li>
<li>使用参数绑定来防止 SQL 注入</li>
<li>随附的测试文件包含检查所有 CRUD 操作和错误处理的场景。</li>
</ol>
<p><strong>解答</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">	_ <span class="string">&quot;modernc.org/sqlite&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Product 定义产品结构体，与数据库表字段一一对应</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID       <span class="type">int64</span></span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Price    <span class="type">float64</span></span><br><span class="line">	Quantity <span class="type">int</span></span><br><span class="line">	Category <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductStore 管理所有产品相关的数据库操作</span></span><br><span class="line"><span class="keyword">type</span> ProductStore <span class="keyword">struct</span> &#123;</span><br><span class="line">	db *sql.DB <span class="comment">// 数据库连接池（复用连接，提高性能）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewProductStore 创建 ProductStore 实例（依赖注入数据库连接，便于测试）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProductStore</span><span class="params">(db *sql.DB)</span></span> *ProductStore &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;ProductStore&#123;db: db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// InitDB 初始化数据库：创建连接 + 初始化产品表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitDB</span><span class="params">(dbPath <span class="type">string</span>)</span></span> (*sql.DB, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 1. 打开 SQLite 数据库连接（文件不存在会自动创建）</span></span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;sqlite&quot;</span>, dbPath)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to open database: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 测试连接可用性（避免连接成功但无法使用的情况）</span></span><br><span class="line">	<span class="keyword">if</span> pingErr := db.Ping(); pingErr != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to ping database: %w&quot;</span>, pingErr)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 创建产品表（带约束：非空、自增、默认值）</span></span><br><span class="line">	createTableSQL := <span class="string">`</span></span><br><span class="line"><span class="string">	CREATE TABLE IF NOT EXISTS products (</span></span><br><span class="line"><span class="string">		id INTEGER PRIMARY KEY AUTOINCREMENT,</span></span><br><span class="line"><span class="string">		name TEXT NOT NULL,</span></span><br><span class="line"><span class="string">		price REAL NOT NULL,</span></span><br><span class="line"><span class="string">		quantity INTEGER NOT NULL DEFAULT 0,</span></span><br><span class="line"><span class="string">		category TEXT</span></span><br><span class="line"><span class="string">	);`</span></span><br><span class="line">	_, err = db.Exec(createTableSQL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to create products table: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> db, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateProduct 新增产品：插入数据库并返回自增 ID</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductStore)</span></span> CreateProduct(product *Product) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 校验必填字段（业务约束）</span></span><br><span class="line">	<span class="keyword">if</span> product.Name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product name cannot be empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> product.Price &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product price cannot be negative&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> product.Quantity &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product quantity cannot be negative&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入 SQL（使用参数绑定，防止 SQL 注入）</span></span><br><span class="line">	insertSQL := <span class="string">`</span></span><br><span class="line"><span class="string">	INSERT INTO products (name, price, quantity, category)</span></span><br><span class="line"><span class="string">	VALUES (?, ?, ?, ?);`</span></span><br><span class="line">	result, err := ps.db.Exec(insertSQL, product.Name, product.Price, product.Quantity, product.Category)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to insert product: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取数据库生成的自增 ID，并赋值给 product（方便调用者使用）</span></span><br><span class="line">	id, err := result.LastInsertId()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to get last insert ID: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	product.ID = id</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetProduct 按 ID 查询产品：不存在返回明确错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductStore)</span></span> GetProduct(id <span class="type">int64</span>) (*Product, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 1. 校验 ID 合法性</span></span><br><span class="line">	<span class="keyword">if</span> id &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;product ID must be positive&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 单条查询（QueryRow 用于返回单行结果）</span></span><br><span class="line">	querySQL := <span class="string">`</span></span><br><span class="line"><span class="string">	SELECT id, name, price, quantity, category</span></span><br><span class="line"><span class="string">	FROM products</span></span><br><span class="line"><span class="string">	WHERE id = ?;`</span></span><br><span class="line">	row := ps.db.QueryRow(querySQL, id)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 扫描结果到 Product 结构体</span></span><br><span class="line">	product := &amp;Product&#123;&#125;</span><br><span class="line">	err := row.Scan(&amp;product.ID, &amp;product.Name, &amp;product.Price, &amp;product.Quantity, &amp;product.Category)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> err == sql.ErrNoRows &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;product with ID %d not found&quot;</span>, id)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to scan product: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> product, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UpdateProduct 更新产品：全字段更新，不存在返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductStore)</span></span> UpdateProduct(product *Product) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 校验必填字段和合法性</span></span><br><span class="line">	<span class="keyword">if</span> product.ID &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product ID must be positive&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> product.Name == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product name cannot be empty&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> product.Price &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product price cannot be negative&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> product.Quantity &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product quantity cannot be negative&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 更新 SQL（参数绑定）</span></span><br><span class="line">	updateSQL := <span class="string">`</span></span><br><span class="line"><span class="string">	UPDATE products</span></span><br><span class="line"><span class="string">	SET name = ?, price = ?, quantity = ?, category = ?</span></span><br><span class="line"><span class="string">	WHERE id = ?;`</span></span><br><span class="line">	result, err := ps.db.Exec(updateSQL, product.Name, product.Price, product.Quantity, product.Category, product.ID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to update product: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 检查是否有记录被更新（RowsAffected 返回影响行数）</span></span><br><span class="line">	rowsAffected, err := result.RowsAffected()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to get rows affected: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;product with ID %d not found&quot;</span>, product.ID)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteProduct 按 ID 删除产品：不存在返回错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductStore)</span></span> DeleteProduct(id <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 校验 ID 合法性</span></span><br><span class="line">	<span class="keyword">if</span> id &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;product ID must be positive&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 删除 SQL（参数绑定）</span></span><br><span class="line">	deleteSQL := <span class="string">`DELETE FROM products WHERE id = ?;`</span></span><br><span class="line">	result, err := ps.db.Exec(deleteSQL, id)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to delete product: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 检查是否有记录被删除</span></span><br><span class="line">	rowsAffected, err := result.RowsAffected()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to get rows affected: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> rowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;product with ID %d not found&quot;</span>, id)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ListProducts 列出产品：支持按分类过滤（空分类返回所有）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductStore)</span></span> ListProducts(category <span class="type">string</span>) ([]*Product, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		rows *sql.Rows</span><br><span class="line">		err  <span class="type">error</span></span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 动态构建查询 SQL：根据分类是否为空决定是否过滤</span></span><br><span class="line">	<span class="keyword">if</span> category == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="comment">// 空分类：查询所有产品</span></span><br><span class="line">		rows, err = ps.db.Query(<span class="string">&quot;SELECT id, name, price, quantity, category FROM products;&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 非空分类：按分类过滤（参数绑定）</span></span><br><span class="line">		rows, err = ps.db.Query(<span class="string">`</span></span><br><span class="line"><span class="string">			SELECT id, name, price, quantity, category</span></span><br><span class="line"><span class="string">			FROM products</span></span><br><span class="line"><span class="string">			WHERE category = ?;`</span>, category)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to query products: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> rows.Close() <span class="comment">// 确保结果集最终关闭，避免资源泄漏</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历结果集，构建产品切片</span></span><br><span class="line">	<span class="keyword">var</span> products []*Product</span><br><span class="line">	<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">		product := &amp;Product&#123;&#125;</span><br><span class="line">		err := rows.Scan(&amp;product.ID, &amp;product.Name, &amp;product.Price, &amp;product.Quantity, &amp;product.Category)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to scan product: %w&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		products = <span class="built_in">append</span>(products, product)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查遍历过程中是否有错误（如数据库连接中断）</span></span><br><span class="line">	<span class="keyword">if</span> err := rows.Err(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;failed to iterate products: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> products, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BatchUpdateInventory 批量更新库存：事务保证原子性</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductStore)</span></span> BatchUpdateInventory(updates <span class="keyword">map</span>[<span class="type">int64</span>]<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 校验输入合法性（不变）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(updates) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;no inventory updates provided&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> id, quantity := <span class="keyword">range</span> updates &#123;</span><br><span class="line">		<span class="keyword">if</span> id &lt;= <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid product ID: %d (must be positive)&quot;</span>, id)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> quantity &lt; <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;invalid quantity for product %d: %d (cannot be negative)&quot;</span>, id, quantity)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 开始事务（不变）</span></span><br><span class="line">	tx, err := ps.db.Begin()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to begin transaction: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 修复：优化事务回滚/提交逻辑，确保错误时优先回滚</span></span><br><span class="line">	<span class="keyword">var</span> rollbackErr <span class="type">error</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 无论 err 是否为 nil，都需处理事务（避免孤儿事务）</span></span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 有错误：强制回滚</span></span><br><span class="line">			rollbackErr = tx.Rollback()</span><br><span class="line">			<span class="keyword">if</span> rollbackErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = fmt.Errorf(<span class="string">&quot;rollback failed: %w (original error: %v)&quot;</span>, rollbackErr, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 无错误：提交</span></span><br><span class="line">			commitErr := tx.Commit()</span><br><span class="line">			<span class="keyword">if</span> commitErr != <span class="literal">nil</span> &#123;</span><br><span class="line">				err = fmt.Errorf(<span class="string">&quot;commit failed: %w&quot;</span>, commitErr)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 预编译更新 SQL（使用 tx 预编译，确保在事务内）</span></span><br><span class="line">	updateSQL := <span class="string">`UPDATE products SET quantity = ? WHERE id = ?;`</span></span><br><span class="line">	stmt, err := tx.Prepare(updateSQL)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to prepare update statement: %w&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="comment">// 关闭预编译语句，避免资源泄漏</span></span><br><span class="line">		closeErr := stmt.Close()</span><br><span class="line">		<span class="keyword">if</span> closeErr != <span class="literal">nil</span> &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;failed to close statement: %w&quot;</span>, closeErr)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5. 遍历更新列表，执行批量更新（不变）</span></span><br><span class="line">	<span class="keyword">for</span> id, quantity := <span class="keyword">range</span> updates &#123;</span><br><span class="line">		result, execErr := stmt.Exec(quantity, id)</span><br><span class="line">		<span class="keyword">if</span> execErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// 执行错误：返回错误，触发 defer 回滚</span></span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;failed to update product %d: %w&quot;</span>, id, execErr)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查产品是否存在</span></span><br><span class="line">		rowsAffected, raErr := result.RowsAffected()</span><br><span class="line">		<span class="keyword">if</span> raErr != <span class="literal">nil</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;failed to get rows affected for product %d: %w&quot;</span>, id, raErr)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> rowsAffected == <span class="number">0</span> &#123;</span><br><span class="line">			err = fmt.Errorf(<span class="string">&quot;product with ID %d not found&quot;</span>, id)</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 所有更新成功，返回 nil，触发 defer 提交</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在 Go 数据库编程中，<code>Exec</code>、<code>Prepare</code>、<code>Query</code>（含 <code>QueryRow</code>）的使用场景完全由 <strong>SQL 操作类型</strong> 和 <strong>执行频率</strong> 决定，核心原则是：<strong>按操作类型选基础方法，按执行频率决定是否预编译</strong>。</p>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>适用场景</strong></th>
<th><strong>返回结果</strong></th>
<th><strong>是否返回结果集</strong></th>
<th><strong>典型用途</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>db.Exec()</code></td>
<td>写操作（无返回结果集）</td>
<td><code>sql.Result</code>（影响行数、自增 ID）+ 错误</td>
<td>❌ 无</td>
<td>INSERT&#x2F;UPDATE&#x2F;DELETE、建表</td>
</tr>
<tr>
<td><code>db.Query()</code></td>
<td>读操作（返回多行结果）</td>
<td><code>*sql.Rows</code>（结果集）+ 错误</td>
<td>✅ 多行</td>
<td>批量查询（如 ListProducts）</td>
</tr>
<tr>
<td><code>db.QueryRow()</code></td>
<td>读操作（返回单行结果）</td>
<td><code>*sql.Row</code>（单行结果）</td>
<td>✅ 单行</td>
<td>按 ID 查询（如 GetProduct）</td>
</tr>
<tr>
<td><code>db.Prepare()</code></td>
<td>预编译 SQL（重复执行同一 SQL 时）</td>
<td><code>*sql.Stmt</code>（预编译语句）+ 错误</td>
<td>-</td>
<td>批量更新 &#x2F; 插入（如 BatchUpdate）</td>
</tr>
</tbody></table>
<p><strong>1. 用</strong> <code>**Exec**</code><strong>：所有「写操作」（无结果集返回）</strong></p>
<p><strong>核心场景</strong>：执行 INSERT、UPDATE、DELETE、CREATE TABLE、DROP 等不返回数据的 SQL 操作。</p>
<p><strong>关键特点</strong>：返回 <code>sql.Result</code> 对象，可获取「影响行数」（<code>RowsAffected()</code>）和「自增 ID」（<code>LastInsertId()</code>），适合判断操作是否生效（如更新 &#x2F; 删除时检查是否有记录被修改）。</p>
<p><strong>2. 用</strong> <code>**Query**</code><strong>：读操作（返回多行结果）</strong></p>
<p><strong>核心场景</strong>：执行 SELECT 语句，且预期返回多条数据（如列表查询、过滤查询）。</p>
<p><strong>关键特点</strong>：返回 <code>*sql.Rows</code> 结果集，需手动遍历读取数据，且必须调用 <code>rows.Close()</code> 释放资源（建议用 <code>defer</code>）。</p>
<p><strong>3. 用</strong> <code>**QueryRow**</code><strong>：读操作（返回单行结果）</strong></p>
<p><strong>核心场景</strong>：执行 SELECT 语句，且预期返回 0 或 1 条数据（如按 ID 查询、唯一键查询）。</p>
<p><strong>关键特点</strong>：返回 <code>*sql.Row</code> 对象，直接调用 <code>Scan()</code> 读取数据，无需遍历，代码更简洁。</p>
<p><strong>4. 用</strong> <code>**Prepare**</code><strong>：预编译 SQL（重复执行同一 SQL）</strong></p>
<p><strong>核心场景</strong>：同一 SQL 语句需要被多次执行（如批量更新、批量插入），通过预编译减少 SQL 解析开销，提升性能。</p>
<p><strong>关键特点</strong>：</p>
<ul>
<li>预编译后生成 <code>*sql.Stmt</code> 对象，后续执行时仅需传入参数（无需重新解析 SQL）。</li>
<li><code>Stmt</code> 可重复使用，执行完成后需调用 <code>Stmt.Close()</code> 释放资源。</li>
<li>支持事务内预编译（<code>tx.Prepare()</code>），确保预编译语句绑定到事务。</li>
</ul>
<p><strong>何时不需要用</strong> <code>**Prepare**</code>：</p>
<ul>
<li>SQL 仅执行一次（如单次插入、单次查询）：直接用 <code>Exec</code>&#x2F;<code>Query</code>&#x2F;<code>QueryRow</code> 更简洁（内部会自动处理解析，无需手动预编译）。</li>
<li>SQL 语句动态变化（如动态拼接查询条件）：预编译无意义（每次 SQL 都不同，无法复用）。</li>
</ul>
<p><strong>常见误区避坑</strong></p>
<ol>
<li><strong>误区 1</strong>：用 <code>Query</code> 执行写操作（如 UPDATE）错误原因：<code>Query</code> 会创建结果集，即使写操作无返回数据，也会占用资源，且无法获取 <code>RowsAffected()</code>。正确做法：写操作一律用 <code>Exec</code>。</li>
<li><strong>误区 2</strong>：每次执行 SQL 都用 <code>Prepare</code>错误原因：单次执行时，预编译的解析开销大于收益，且代码冗余。正确做法：仅当 SQL 重复执行时用 <code>Prepare</code>。</li>
<li><strong>误区 3</strong>：忽略 <code>rows.Close()</code> 或 <code>stmt.Close()</code>错误原因：资源泄漏，导致数据库连接池耗尽。正确做法：用 <code>defer</code> 立即关闭（如 <code>defer rows.Close()</code>、<code>defer stmt.Close()</code>）。</li>
<li><strong>误区 4</strong>：用 <code>QueryRow</code> 处理多行结果错误原因：<code>QueryRow</code> 仅返回第一行数据，后续数据会被忽略，导致数据丢失。正确做法：多行结果用 <code>Query</code> 遍历。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/28/13-%E8%BF%9B%E8%A1%8C%20SQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/" data-id="cuid0O1CDOEEHRRgP-7kERyPn" data-title="#13.进行 SQL 数据库操作" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go-Interview-Practice/" rel="tag">Go Interview Practice</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-4-并发BFS查询" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/26/4-%E5%B9%B6%E5%8F%91BFS%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time class="dt-published" datetime="2025-11-26T02:24:30.000Z" itemprop="datePublished">2025-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/26/4-%E5%B9%B6%E5%8F%91BFS%E6%9F%A5%E8%AF%A2/">#4.并发BFS查询</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>题目</strong></p>
<p>你需要在单个图上同时处理多个广度优先搜索（BFS）查询。每个查询都指定了一个起始节点，你必须计算出从该节点开始的BFS顺序。与简单的单线程BFS不同，你的解决方案应利用协程和通道（或并发安全的数据结构）来高效并行地处理多个查询。</p>
<p><strong>函数</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentBFSQueries</span><span class="params">(graph <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>, queries []<span class="type">int</span>, numWorkers <span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span></span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<p>graph：以邻接表形式表示的图。</p>
<p>key是一个节点（一个整数）。</p>
<p>value是一组相邻节点的切片。</p>
<p>queries：一组必须执行广度优先搜索（BFS）的起始节点。</p>
<p>numWorkers：并发处理这些广度优先搜索（BFS）查询的协程（工作线程）数量。</p>
<p><strong>返回</strong></p>
<p>从查询节点出发，到以该节点为起点的广度优先搜索（BFS）顺序的映射。</p>
<p><strong>要求</strong> </p>
<ol>
<li>你必须使用并发机制（goroutines + channels，或并发安全的数据结构）来并行处理广度优先搜索（BFS）查询。</li>
<li>采用简单或纯顺序的方法可能会过于缓慢，尤其是在处理大型图和大量查询时。</li>
<li>广度优先搜索（BFS）算法本身可以是标准的（使用队列），但如果工作线程可用，则每个BFS查询都应并发运行。</li>
</ol>
<p><strong>示例用法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    graph := <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>&#123;</span><br><span class="line">        <span class="number">0</span>: &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        <span class="number">1</span>: &#123;<span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        <span class="number">2</span>: &#123;<span class="number">3</span>&#125;,</span><br><span class="line">        <span class="number">3</span>: &#123;<span class="number">4</span>&#125;,</span><br><span class="line">        <span class="number">4</span>: &#123;&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    queries := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">    numWorkers := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    results := ConcurrentBFSQueries(graph, queries, numWorkers)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       Possible output:</span></span><br><span class="line"><span class="comment">       results[0] = [0 1 2 3 4]</span></span><br><span class="line"><span class="comment">       results[1] = [1 2 3 4]</span></span><br><span class="line"><span class="comment">       results[2] = [2 3 4]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解答</strong></p>
<p><strong>1.先不考虑并发机制，使用BFS广度优先搜索</strong></p>
<p><em><strong>tips：</strong></em></p>
<p>BFS 通常借助队列来实现，队列具有“先入先出”的性质，这与 BFS 的“由近及远”的思想异曲同工。</p>
<ol>
<li>将遍历起始顶点 加入队列，并开启循环。</li>
<li>在循环的每轮迭代中，弹出队首顶点并记录访问，然后将该顶点的所有邻接顶点加入到队列尾部。</li>
<li>循环步骤 2. ，直到所有顶点被访问完毕后结束。</li>
<li>为了防止重复遍历顶点，我们需要借助一个哈希集合 visited 来记录哪些节点已被访问。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFSQueries</span><span class="params">(graph <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>, node <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(graph) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置一个切片 用于记录当前遍历的顶点 实现队列的效果</span></span><br><span class="line">	queue := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 第一个节点先入队</span></span><br><span class="line">	queue = <span class="built_in">append</span>(queue, node)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置一个map 用于存储已经访问的节点</span></span><br><span class="line">	visited := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	<span class="comment">// 第一个节点先存入</span></span><br><span class="line">	visited[node] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 最终结果</span></span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 以顶点 node 为起点，循环直至访问完所有顶点</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 队首顶点出队</span></span><br><span class="line">		vet := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		<span class="comment">// 记录访问顶点</span></span><br><span class="line">		res = <span class="built_in">append</span>(res, vet)</span><br><span class="line">		<span class="comment">// 遍历该顶点的所有邻接顶点</span></span><br><span class="line">		<span class="keyword">for</span> _, key := <span class="keyword">range</span> graph[vet] &#123;</span><br><span class="line">			<span class="keyword">if</span> _, ok := visited[key]; !ok &#123;</span><br><span class="line">				<span class="comment">// 只入队未访问的顶点</span></span><br><span class="line">				queue = <span class="built_in">append</span>(queue, key)</span><br><span class="line">				visited[key] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中传入参数：图和需要遍历的节点，返回该节点下的图BFS遍历结果</p>
<p><strong>2.引入并发机制，加入协程</strong></p>
<p>开启多个线程对不同的节点进行遍历，需要注意并发控制</p>
<p>如何引入go的并发机制，给定工作线程数n和数组length，以此遍历输出数组中的值（不要求顺序）</p>
<p><strong>方案一：使用 sync.WaitGroup（最常用）</strong></p>
<p>适合简单的并发任务，需要等待所有 goroutine 完成后再继续执行。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">    n := <span class="number">3</span> <span class="comment">// 工作线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通道用于传递数组索引</span></span><br><span class="line">    idxChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充索引到通道</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        idxChan &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(idxChan) <span class="comment">// 关闭通道，告知goroutine没有更多任务</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动工作线程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">for</span> idx := <span class="keyword">range</span> idxChan &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;工作线程 %d: 数组索引 %d, 值为 %d\n&quot;</span>, workerID, idx, arr[idx])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有工作线程完成</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;所有元素遍历完成&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方案二：使用 for range 结合通道（简单场景）</strong></p>
<p>适合数组较小、逻辑简单的并发遍历。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">    n := <span class="number">3</span> <span class="comment">// 工作线程数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建通道，缓冲大小为数组长度</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="built_in">len</span>(arr))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将数组元素发送到通道</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        ch &lt;- v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动工作线程</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(workerID <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="comment">// 从通道接收元素并处理</span></span><br><span class="line">            <span class="keyword">for</span> v := <span class="keyword">range</span> ch &#123;</span><br><span class="line">                fmt.Printf(<span class="string">&quot;工作线程 %d: 值为 %d\n&quot;</span>, workerID, v)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待所有工作线程完成</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;所有元素遍历完成&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>将并发机制与BFS结合</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ConcurrentBFSQueries 并发执行 BFS 查询，返回「节点值 -&gt; BFS 结果」的映射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ConcurrentBFSQueries</span><span class="params">(graph <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>, queries []<span class="type">int</span>, numWorkers <span class="type">int</span>)</span></span> <span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> mu sync.RWMutex</span><br><span class="line">	idxChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="built_in">len</span>(queries))</span><br><span class="line">	results := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>) <span class="comment">// 键：节点值，值：BFS 结果（修复错误 1）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 填充 queries 索引到通道</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> queries &#123;</span><br><span class="line">		idxChan &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(idxChan)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动工作线程</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numWorkers; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> idx := <span class="keyword">range</span> idxChan &#123;</span><br><span class="line">				node := queries[idx]       <span class="comment">// 获取当前要查询的节点值</span></span><br><span class="line">				bfsRes := BFSQueries(&amp;graph, node) <span class="comment">// 传递 map 指针（修复错误 2）</span></span><br><span class="line"></span><br><span class="line">				<span class="comment">// 并发安全写入结果：键为节点值</span></span><br><span class="line">				mu.Lock()</span><br><span class="line">				results[node] = bfsRes</span><br><span class="line">				mu.Unlock()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	<span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFSQueries 接收 map 指针，从 startNode 开始 BFS，返回连通分量（BFS 顺序）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BFSQueries</span><span class="params">(graph *<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>, startNode <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 解引用 map 指针</span></span><br><span class="line">	g := *graph</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化队列、已访问集合、结果切片</span></span><br><span class="line">	queue := []<span class="type">int</span>&#123;startNode&#125;</span><br><span class="line">	visited := <span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;&#123;startNode: &#123;&#125;&#125;</span><br><span class="line">	result := []<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// BFS 核心逻辑</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		currentNode := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当前节点加入结果</span></span><br><span class="line">		result = <span class="built_in">append</span>(result, currentNode)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历当前节点的邻接节点（若节点不存在于图中，g[currentNode] 返回空切片）</span></span><br><span class="line">		<span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> g[currentNode] &#123;</span><br><span class="line">			<span class="keyword">if</span> _, isVisited := visited[neighbor]; !isVisited &#123;</span><br><span class="line">				visited[neighbor] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">				queue = <span class="built_in">append</span>(queue, neighbor)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/26/4-%E5%B9%B6%E5%8F%91BFS%E6%9F%A5%E8%AF%A2/" data-id="cuidWe4_e13ar7solHrDxpMPl" data-title="#4.并发BFS查询" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go-Interview-Practice/" rel="tag">Go Interview Practice</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-5-HTTP认证中间件" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/26/5-HTTP%E8%AE%A4%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="article-date">
  <time class="dt-published" datetime="2025-11-26T02:24:30.000Z" itemprop="datePublished">2025-11-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/26/5-HTTP%E8%AE%A4%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6/">#5.HTTP认证中间件</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Learnings"><a href="#Learnings" class="headerlink" title="Learnings"></a>Learnings</h2><h3 id="Go-中的-HTTP-基础"><a href="#Go-中的-HTTP-基础" class="headerlink" title="Go 中的 HTTP 基础"></a>Go 中的 HTTP 基础</h3><p>Go 的软件包提供了构建 HTTP 服务器所需的一切：<code>net/http</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    http.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>func(w http.ResponseWriter, r *http.Request)</code>，这是 <code>net/http</code> 库要求的处理器格式</p>
<ul>
<li><code>w http.ResponseWriter</code>：「响应写入器」，相当于 HTTP 响应的「输出流」，我们通过它向客户端返回内容（比如文字、HTML、文件等）</li>
<li><code>r *http.Request</code>：「请求对象」，包含客户端发送的所有信息（比如请求路径、参数、请求头、Cookie 等）</li>
</ul>
<h3 id="理解中间件"><a href="#理解中间件" class="headerlink" title="理解中间件"></a>理解中间件</h3><p><strong>1. 什么是中间件</strong></p>
<ul>
<li><strong>中间件</strong>是一种位于<strong>客户端请求</strong>和<strong>你的应用核心逻辑</strong>之间的组件。</li>
<li>它像一个过滤器或管道，所有请求在到达最终处理函数（Handler）之前，以及响应在返回给客户端之前，都可能经过一系列中间件的处理。</li>
</ul>
<p>中间件可以完成以下工作：</p>
<ul>
<li><strong>处理入站请求</strong>：如记录日志、统计请求耗时。</li>
<li><strong>修改请求对象</strong>：如添加或修改请求头、解析认证信息。</li>
<li><strong>提前终止请求</strong>：如身份验证失败时，直接返回 401 响应，不再调用后续的处理函数。这是中间件非常重要的一个功能。</li>
<li><strong>修改响应对象</strong>：如统一添加响应头（如 <code>Content-Type</code>, <code>Server</code>）、压缩响应体。</li>
<li><strong>链式组合</strong>：多个中间件可以串联起来，形成一个处理 pipeline。请求依次经过 <code>中间件1 -&gt; 中间件2 -&gt; ... -&gt; 最终Handler</code>，响应则反向返回。</li>
</ul>
<p><strong>2. 基本中间件结构</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="comment">// 1. 返回一个 http.Handler 接口</span></span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 2. 这是在调用最终处理器（next）之前执行的逻辑</span></span><br><span class="line">        <span class="comment">//    通常称为 &quot;before&quot; 逻辑</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;Before handler&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 调用下一个处理器（next）</span></span><br><span class="line">        <span class="comment">//    这是链条得以继续传递的关键</span></span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 这是在处理器执行完毕后执行的逻辑</span></span><br><span class="line">        <span class="comment">//    通常称为 &quot;after&quot; 逻辑</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;After handler&quot;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>middleware</code> 函数本身不是一个处理器，它是一个<strong>处理器工厂</strong>。它接收一个 <code>next http.Handler</code>（即链条中的下一个处理器）作为参数。</p>
</li>
<li><p>它返回一个新的 <code>http.Handler</code>。这个新的处理器封装了原有的 <code>next</code> 处理器。</p>
</li>
<li><p>在返回的匿名函数 <code>func(w http.ResponseWriter, r *http.Request)</code> 内部：</p>
</li>
<li><p><code>Before handler</code> 的逻辑在 <code>next.ServeHTTP()</code> <strong>之前</strong>执行。</p>
</li>
<li><p><code>next.ServeHTTP(w, r)</code> 这行代码是核心，它会将请求传递给链条中的下一个组件。如果没有这行，请求链就会在这里中断。</p>
</li>
<li><p><code>After handler</code> 的逻辑在 <code>next.ServeHTTP()</code> <strong>之后</strong>执行。这使得中间件可以处理响应，例如记录响应时间、修改响应头等。</p>
</li>
</ul>
<p><strong>3. http.Handler接口</strong></p>
<p>要理解中间件，必须先理解 Go HTTP 包的核心接口 <code>http.Handler</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">    ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个非常简洁的接口，任何类型只要实现了 <code>ServeHTTP</code> 方法，它就是一个 <code>http.Handler</code>。</li>
<li><code>http.ListenAndServe</code> 的第二个参数就是一个 <code>http.Handler</code>，它代表了整个应用的请求处理入口。</li>
</ul>
<p><code>http.HandlerFunc</code> 是一个适配器：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(ResponseWriter, *Request)</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f HandlerFunc)</span></span> ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="line">    f(w, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>它允许你将一个普通的函数（签名为 <code>func(w http.ResponseWriter, r *http.Request)</code>）转换成一个 <code>http.Handler</code> 接口类型。</li>
<li>这就是为什么你可以在 <code>http.HandleFunc(&quot;/path&quot;, myFunc)</code> 中直接传递一个函数，以及为什么在中间件的例子中可以返回 <code>http.HandlerFunc(...)</code>。</li>
</ul>
<p><strong>总结</strong>：中间件模式之所以能工作，就是因为它围绕 <code>http.Handler</code> 这个统一的接口进行设计。中间件接收一个 <code>Handler</code>，并返回一个新的 <code>Handler</code>，从而实现了职责链模式。</p>
<p><strong>4. 链式组合中间件</strong> </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    mux.HandleFunc(<span class="string">&quot;/api&quot;</span>, apiHandler)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 链式包裹 mux</span></span><br><span class="line">    handler := loggingMiddleware(</span><br><span class="line">        authenticationMiddleware(</span><br><span class="line">            rateLimitMiddleware(mux), <span class="comment">// 最内层</span></span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当一个请求到达 <code>/api</code> 时，执行流程如下：</p>
<ol>
<li>请求首先进入最外层的 <code>loggingMiddleware</code> 的 “before” 逻辑（例如，记录开始时间）。</li>
<li><code>loggingMiddleware</code> 调用 <code>next.ServeHTTP</code>，此时 <code>next</code> 是 <code>authenticationMiddleware</code> 返回的处理器。</li>
<li>请求进入 <code>authenticationMiddleware</code> 的 “before” 逻辑（检查身份验证）。</li>
<li><code>authenticationMiddleware</code> 调用 <code>next.ServeHTTP</code>，此时 <code>next</code> 是 <code>rateLimitMiddleware</code> 返回的处理器。</li>
<li>请求进入 <code>rateLimitMiddleware</code> 的 “before” 逻辑（检查速率限制）。</li>
<li><code>rateLimitMiddleware</code> 调用 <code>next.ServeHTTP</code>，此时 <code>next</code> 是 <code>mux</code>（路由器）。</li>
<li><code>mux</code> 根据路径找到并调用最终的 <code>apiHandler</code>。</li>
<li><code>apiHandler</code> 执行完毕，开始返回。</li>
<li>执行 <code>rateLimitMiddleware</code> 的 “after” 逻辑。</li>
<li>执行 <code>authenticationMiddleware</code> 的 “after” 逻辑。</li>
<li>执行 <code>loggingMiddleware</code> 的 “after” 逻辑（例如，记录结束时间和总耗时）。</li>
<li>最终响应返回给客户端。</li>
</ol>
<p><strong>注意函数调用顺序</strong>：<code>loggingMiddleware(authenticationMiddleware(rateLimitMiddleware(mux)))</code> 的写法，在语义上等同于 <code>loggingMiddleware -&gt; authenticationMiddleware -&gt; rateLimitMiddleware -&gt; mux</code>。请求按照这个顺序向下传递，响应则逆序向上传递。</p>
<p><strong>5. 认证中间件模式</strong></p>
<p><strong>基本认证</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">basicAuthMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        username, password, ok := r.BasicAuth() <span class="comment">// 从请求头解析用户名密码</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> !ok || !checkCredentials(username, password) &#123;</span><br><span class="line">            <span class="comment">// 认证失败</span></span><br><span class="line">            w.Header().Set(<span class="string">&quot;WWW-Authenticate&quot;</span>, <span class="string">`Basic realm=&quot;Restricted&quot;`</span>) <span class="comment">// 提示客户端需要基本认证</span></span><br><span class="line">            http.Error(w, <span class="string">&quot;Unauthorized&quot;</span>, http.StatusUnauthorized) <span class="comment">// 返回 401</span></span><br><span class="line">            <span class="keyword">return</span> <span class="comment">// 提前终止，不再调用 next</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 认证成功，继续传递请求</span></span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Token 认证</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tokenAuthMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        authHeader := r.Header.Get(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> authHeader == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;Authorization header required&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        parts := strings.SplitN(authHeader, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> || parts[<span class="number">0</span>] != <span class="string">&quot;Bearer&quot;</span> &#123;</span><br><span class="line">            http.Error(w, <span class="string">&quot;Invalid authorization format&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        token := parts[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> !validateToken(token) &#123; <span class="comment">// 假设存在 validateToken 函数</span></span><br><span class="line">            http.Error(w, <span class="string">&quot;Invalid token&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6. HTTP 请求中的上下文</strong></p>
<p><code>context</code> 包是 Go 中用于在不同 goroutine 之间传递请求范围的信息、取消信号和截止时间的标准方式。在 Web 开发中，它常用于在中间件和最终处理器之间传递数据。</p>
<p><strong>问题背景：</strong></p>
<p>中间件验证了用户身份后，如何将用户信息传递给后续的 <code>apiHandler</code>？直接修改 <code>*http.Request</code> 是不被允许的，也是不好的实践。<code>context</code> 就是为了解决这个问题而生。</p>
<p><strong>使用方法：</strong></p>
<p><strong>（1）定义上下文键</strong><strong>：</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个自定义类型，用于避免键名冲突</span></span><br><span class="line"><span class="keyword">type</span> contextKey <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个具体的键</span></span><br><span class="line"><span class="keyword">const</span> userContextKey contextKey = <span class="string">&quot;user&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>为什么使用自定义类型？</strong> 因为 <code>context.WithValue</code> 的键是 <code>interface{}</code> 类型。如果大家都用 <code>string</code> 作为键，就可能发生冲突。使用一个包内私有的自定义类型可以确保键的唯一性。</p>
<p><strong>（2）在中间件中存储值</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">authMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ... 验证 token 或密码 ...</span></span><br><span class="line">        username := <span class="string">&quot;john_doe&quot;</span> <span class="comment">// 假设从 token 中解析出用户名</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建一个新的 context，并将用户名存储进去</span></span><br><span class="line">        <span class="comment">// r.Context() 是请求自带的上下文</span></span><br><span class="line">        ctx := context.WithValue(r.Context(), userContextKey, username)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将带有新上下文的请求对象传递给下一个处理器</span></span><br><span class="line">        next.ServeHTTP(w, r.WithContext(ctx))</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）在处理器中获取值</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apiHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 从请求的上下文中获取值</span></span><br><span class="line">    <span class="comment">// 需要使用类型断言来转换回原始类型</span></span><br><span class="line">    user, ok := r.Context().Value(userContextKey).(<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">// 如果没有找到或类型不匹配，说明中间件可能没有执行</span></span><br><span class="line">        http.Error(w, <span class="string">&quot;User not found in context&quot;</span>, http.StatusInternalServerError)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成功获取到用户信息并使用</span></span><br><span class="line">    fmt.Fprintf(w, <span class="string">&quot;Hello, %s!&quot;</span>, user) <span class="comment">// 输出: Hello, john_doe!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JWT-JSON-Web-Token-认证方案的实现"><a href="#JWT-JSON-Web-Token-认证方案的实现" class="headerlink" title="JWT (JSON Web Token) 认证方案的实现"></a>JWT (JSON Web Token) 认证方案的实现</h3><p><strong>1.什么是JWT</strong></p>
<p>JWT 是一种<strong>无状态</strong>的认证机制。它的核心思想是：用户在第一次登录成功后，服务器生成一个包含用户信息和过期时间的 Token 返回给客户端。客户端在后续的所有请求中，都需要在 HTTP 头部带上这个Token 来证明自己的身份。服务器收到请求后，只需验证这个 Token 的签名和有效性，无需再查询数据库。</p>
<p><strong>2.JWT的实现</strong></p>
<p>包括了 <strong>创建 Token</strong>、<strong>验证 Token</strong> 和 <strong>中间件</strong> </p>
<ol>
<li><code>**createToken**</code>: 用于在用户成功登录时，生成并返回一个 JWT。</li>
<li><code>**verifyToken**</code>: 用于在后续请求中，验证客户端传来的 JWT 是否有效。</li>
<li><code>**jwtMiddleware**</code>: 一个 HTTP 中间件，它将 <code>verifyToken</code> 的逻辑集成到 Web 服务的请求处理链中，为需要保护的路由提供自动的 JWT 认证。</li>
</ol>
<p>导入JWT模块</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> get <span class="string">&quot;github.com/golang-jwt/jwt/v4&quot;</span></span><br></pre></td></tr></table></figure>

<p>（1）创建 Token: <code>createToken(username string, secret []byte) (string, error)</code></p>
<p>这个函数的作用是根据用户名和一个密钥，生成一个 JWT 字符串。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createToken</span><span class="params">(username <span class="type">string</span>, secret []<span class="type">byte</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 定义token的claims</span></span><br><span class="line">    token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims&#123;</span><br><span class="line">        <span class="string">&quot;username&quot;</span>: username,</span><br><span class="line">        <span class="string">&quot;exp&quot;</span>:      time.Now().Add(time.Hour * <span class="number">24</span>).Unix(),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> token.SignedString(secret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>**jwt.NewWithClaims(...)**</code>: 这是创建一个新 Token 对象的入口。</p>
</li>
<li><p>第一个参数 <code>jwt.SigningMethodHS256</code> 指定了这个 Token 将要使用的<strong>签名算法</strong>。<code>HS256</code> 代表 HMAC-SHA256，这是一种对称加密算法，意味着同一个密钥（<code>secret</code>）既用于签名也用于验证。</p>
</li>
<li><p>第二个参数 <code>jwt.MapClaims{...}</code> 是 Token 的<strong>载荷（Payload）</strong>，也称为 Claims。它是一个 JSON 对象，包含了关于用户和 Token 本身的元数据。</p>
</li>
<li><p><code>&quot;username&quot;: username</code>: 这是一个<strong>自定义 claim</strong>，我们将用户名存储在 Token 中，方便后续识别用户。</p>
</li>
<li><p><code>&quot;exp&quot;: time.Now().Add(time.Hour * 24).Unix()</code>: 这是一个<strong>标准 claim</strong>，代表 Token 的<strong>过期时间（expiration time）</strong>。<code>Unix()</code> 方法返回从 Unix 纪元（1970 年 1 月 1 日）到当前时间（加 24 小时）的秒数。这是 JWT 实现无状态认证的关键，服务器可以根据这个字段判断 Token 是否有效，而无需存储任何会话信息。</p>
</li>
<li><p><code>**token.SignedString(secret)**</code>: 这是生成最终 Token 字符串的关键步骤。</p>
</li>
<li><p>它会将 Token 的头部（Header）、载荷（Payload）和你提供的 <code>secret</code> 密钥按照 <code>HS256</code> 算法进行加密签名。</p>
</li>
<li><p>最终返回的字符串是一个由 <code>.</code> 分隔的三部分组成的字符串：<code>Header.Payload.Signature</code>。这个字符串就是客户端需要存储和在后续请求中发送的 JWT。</p>
</li>
</ul>
<p>（2） 验证 Token: <code>verifyToken(tokenString string, secret []byte) (jwt.MapClaims, error)</code></p>
<p>这个函数的作用是接收一个客户端传来的 JWT 字符串，并用密钥验证其有效性。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyToken</span><span class="params">(tokenString <span class="type">string</span>, secret []<span class="type">byte</span>)</span></span> (jwt.MapClaims, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析token</span></span><br><span class="line">    token, err := jwt.Parse(tokenString, <span class="function"><span class="keyword">func</span><span class="params">(token *jwt.Token)</span></span> (<span class="keyword">interface</span>&#123;&#125;, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="comment">// 在回调函数中验证签名方法</span></span><br><span class="line">        <span class="keyword">if</span> _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Unexpected signing method: %v&quot;</span>, token.Header[<span class="string">&quot;alg&quot;</span>])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回用于验证签名的密钥</span></span><br><span class="line">        <span class="keyword">return</span> secret, <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果解析过程中出现错误</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查token是否有效，并提取Claims</span></span><br><span class="line">    <span class="keyword">if</span> claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid &#123;</span><br><span class="line">        <span class="keyword">return</span> claims, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果token无效 如已过期</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;Token is invalid&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>**jwt.Parse(...)**</code>: 这是验证 Token 的核心函数。</p>
</li>
<li><p>第一个参数是客户端传来的 <code>tokenString</code>。</p>
</li>
<li><p>第二个参数是一个<strong>回调函数（Keyfunc）</strong>，这是整个验证过程中最关键的部分。<code>jwt.Parse</code> 会先解析 Token 的 Header 和 Payload，然后调用这个回调函数来获取用于验证签名的密钥。</p>
</li>
<li><p><strong>回调函数 (Keyfunc)</strong>:</p>
</li>
<li><p><strong>验证签名算法</strong>: <code>if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok</code>。这是一个重要的安全检查。它确保客户端发送的 Token 使用的签名算法与服务器预期的（<code>HS256</code>）一致。如果不一致，直接返回错误。这可以防止攻击者使用不安全的算法（如无签名的 “none” 算法）来伪造 Token。</p>
</li>
<li><p><strong>返回密钥</strong>: <code>return secret, nil</code>。函数最后返回用于验证签名的密钥。<code>jwt.Parse</code> 会使用这个密钥和解析出的签名算法，对 Token 的签名部分进行验证。</p>
</li>
<li><p><strong>错误处理</strong>:</p>
</li>
<li><p>如果 <code>jwt.Parse</code> 在解析或验证过程中发现任何问题（例如，签名不匹配、Token 格式错误等），它会返回一个非 <code>nil</code> 的 <code>err</code>。</p>
</li>
<li><p><strong>提取和检查 Claims</strong>:</p>
</li>
<li><p><code>if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid</code>。</p>
</li>
<li><p><code>token.Claims</code> 包含了 Token 的载荷。我们需要将它断言为 <code>jwt.MapClaims</code> 类型（一个 <code>map[string]interface{}</code>）才能方便地访问其中的数据。</p>
</li>
<li><p><code>token.Valid</code> 是一个布尔值，它综合了所有内置的验证逻辑，其中最重要的就是<strong>检查</strong> <code>**exp**</code><strong>（过期时间）</strong>。如果当前时间已经超过了 <code>exp</code> 中指定的时间，<code>token.Valid</code> 会是 <code>false</code>。</p>
</li>
<li><p><strong>返回结果</strong>:</p>
</li>
<li><p>如果正常，函数返回<code>(claims, nil)</code>，调用者可以从<code>claims</code>中获取用户信息（如<code>username</code>）。</p>
</li>
<li><p>如果 Token 无效（包括已过期），则返回 <code>(nil, error)</code>。</p>
</li>
</ul>
<p>（3）JWT 中间件: <code>jwtMiddleware(secret []byte) func(http.Handler) http.Handler</code></p>
<p>这个函数是一个<strong>中间件工厂</strong>。它接收一个 <code>secret</code> 并返回一个标准的 HTTP 中间件。这个中间件的作用是在请求到达业务逻辑处理器之前，自动完成 JWT 的验证。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">jwtMiddleware</span><span class="params">(secret []<span class="type">byte</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">    <span class="comment">// 返回一个中间件函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">        <span class="comment">// 返回一个 http.Handler</span></span><br><span class="line">        <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">            <span class="comment">// 从 Authorization 头中获取 Token</span></span><br><span class="line">            authHeader := r.Header.Get(<span class="string">&quot;Authorization&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> authHeader == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">                http.Error(w, <span class="string">&quot;Authorization header required&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析 &quot;Bearer &lt;token&gt;&quot; 格式</span></span><br><span class="line">            parts := strings.SplitN(authHeader, <span class="string">&quot; &quot;</span>, <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(parts) != <span class="number">2</span> || parts[<span class="number">0</span>] != <span class="string">&quot;Bearer&quot;</span> &#123;</span><br><span class="line">                http.Error(w, <span class="string">&quot;Invalid authorization format&quot;</span>, http.StatusUnauthorized)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            tokenString := parts[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 verifyToken 函数验证 Token</span></span><br><span class="line">            claims, err := verifyToken(tokenString, secret)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                http.Error(w, <span class="string">&quot;Invalid token: &quot;</span>+err.Error(), http.StatusUnauthorized)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将用户信息存入 Context</span></span><br><span class="line">            username := claims[<span class="string">&quot;username&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">            ctx := context.WithValue(r.Context(), userContextKey, username)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将请求传递给下一个处理器</span></span><br><span class="line">            next.ServeHTTP(w, r.WithContext(ctx))</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>获取 Token</strong>: 它首先检查 HTTP 请求头 <code>Authorization</code> 是否存在。</li>
<li><strong>解析格式</strong>: JWT 通常使用 <code>Bearer</code> 方案，所以 <code>Authorization</code> 头的格式是 <code>Bearer &lt;token&gt;</code>。代码通过 <code>strings.SplitN</code> 来提取出 <code>&lt;token&gt;</code> 部分。</li>
<li><strong>验证 Token</strong>: 调用我们上面分析过的 <code>verifyToken</code> 函数来验证 Token 的有效性。</li>
<li><strong>处理结果</strong>:</li>
</ol>
<ul>
<li>如果验证失败（包括 header 不存在、格式错误、Token 无效等），中间件会立即返回一个 <code>401 Unauthorized</code> 错误，并终止请求。</li>
<li>如果验证成功，它会从 <code>claims</code> 中提取出 <code>username</code>，并将其存入请求的 <code>Context</code> 中，就像 Basic Auth 中间件那样。</li>
</ul>
<ol>
<li><strong>传递请求</strong>: 最后，调用 <code>next.ServeHTTP(w, r.WithContext(ctx))</code> 将带有用户信息的请求传递给后续的业务逻辑处理器。</li>
</ol>
<hr>
<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><strong>问题</strong></p>
<p>在这个挑战中，你必须在 Go 中实现一个 HTTP 中间件，检查每个入站请求是否存在有效的认证令牌。如果令牌无效，中间件应返回HTTP 401未授权响应。如果有效，应将请求传递给下一个处理器。</p>
<p><strong>要求</strong></p>
<ol>
<li>中间件寻找HTTP头“X-Auth-Token”。</li>
<li>如果有头部并且等于预定义的“secret”，则请求被允许，并应传递给最终处理程序。</li>
<li>否则，请返回401 Unauthorized。</li>
<li>路由器有两个端点：</li>
</ol>
<ul>
<li>GET &#x2F;hello -&gt; 回应“Hello！”</li>
<li>GET &#x2F;secure -&gt; 回复“You are authorized！”</li>
</ul>
<ol>
<li>附带的测试文件包含10个场景，检查有效令牌、无效令牌、缺失头部等行为。</li>
</ol>
<p><strong>解答</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validToken = <span class="string">&quot;secret&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AuthMiddleware checks the &quot;X-Auth-Token&quot; header.</span></span><br><span class="line"><span class="comment">// If it&#x27;s &quot;secret&quot;, call the next handler.</span></span><br><span class="line"><span class="comment">// Otherwise, respond with 401 Unauthorized.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AuthMiddleware</span><span class="params">(next http.Handler)</span></span> http.Handler &#123;</span><br><span class="line">	<span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">		authHeader := r.Header.Get(<span class="string">&quot;X-Auth-Token&quot;</span>)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> authHeader != <span class="string">&quot;secret&quot;</span> &#123;</span><br><span class="line">			w.WriteHeader(http.StatusUnauthorized)</span><br><span class="line">			<span class="keyword">return</span> </span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		next.ServeHTTP(w,r)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// helloHandler returns &quot;Hello!&quot; on GET /hello</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">helloHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprint(w, <span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// secureHandler returns &quot;You are authorized!&quot; on GET /secure</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">secureHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprint(w, <span class="string">&quot;You are authorized!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetupServer configures the HTTP routes with the authentication middleware.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SetupServer</span><span class="params">()</span></span> http.Handler &#123;</span><br><span class="line">	mux := http.NewServeMux()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Public route: /hello (no auth required)</span></span><br><span class="line">	mux.HandleFunc(<span class="string">&quot;/hello&quot;</span>, helloHandler)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Secure route: /secure</span></span><br><span class="line">	<span class="comment">// Wrap with AuthMiddleware</span></span><br><span class="line">	secureRoute := http.HandlerFunc(secureHandler)</span><br><span class="line">	mux.Handle(<span class="string">&quot;/secure&quot;</span>, AuthMiddleware(secureRoute))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> mux</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Optional: you can run a real server for local testing</span></span><br><span class="line">	<span class="comment">// http.ListenAndServe(&quot;:8080&quot;, SetupServer())</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/26/5-HTTP%E8%AE%A4%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6/" data-id="cuidy2rdYj-ZOUzLa6ikIBNLh" data-title="#5.HTTP认证中间件" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go-Interview-Practice/" rel="tag">Go Interview Practice</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GoByExample(down)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/12/GoByExample(down)/" class="article-date">
  <time class="dt-published" datetime="2025-11-12T01:35:00.000Z" itemprop="datePublished">2025-11-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/12/GoByExample(down)/">Go语言基础学习（下）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文根据《Go by Example》进行学习，参考资料出自<a target="_blank" rel="noopener" href="https://gobyexample-cn.github.io/">https://gobyexample-cn.github.io/</a></p>
<p>上篇包括Go语言基础部分，从Hello World到错误处理；中篇包括协程与通道；下篇包括各种工具类的使用。</p>
        
          <p class="article-more-link">
            <a href="/2025/11/12/GoByExample(down)/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/12/GoByExample(down)/" data-id="cuidb2l0QpSC3z1aD4YHm-S0i" data-title="Go语言基础学习（下）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go%E5%AD%A6%E4%B9%A0/" rel="tag">Go学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GoByExample(mid)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/11/GoByExample(mid)/" class="article-date">
  <time class="dt-published" datetime="2025-11-11T02:22:00.000Z" itemprop="datePublished">2025-11-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/11/GoByExample(mid)/">Go语言基础学习（中）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文根据《Go by Example》进行学习，参考资料出自<a target="_blank" rel="noopener" href="https://gobyexample-cn.github.io/">https://gobyexample-cn.github.io/</a></p>
<p>上篇包括Go语言基础部分，从Hello World到错误处理；中篇包括协程与通道；下篇包括各种工具类的使用。</p>
        
          <p class="article-more-link">
            <a href="/2025/11/11/GoByExample(mid)/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/11/GoByExample(mid)/" data-id="cuidlCvZDsJ3i9H8GTDj1WzIL" data-title="Go语言基础学习（中）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go%E5%AD%A6%E4%B9%A0/" rel="tag">Go学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-GoByExample(up)" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/07/GoByExample(up)/" class="article-date">
  <time class="dt-published" datetime="2025-11-07T01:02:02.000Z" itemprop="datePublished">2025-11-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/07/GoByExample(up)/">Go语言基础学习（上）</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>本文根据《Go by Example》进行学习，参考资料出自<a target="_blank" rel="noopener" href="https://gobyexample-cn.github.io/">https://gobyexample-cn.github.io/</a></p>
<p>上篇包括Go语言基础部分，从Hello World到错误处理；中篇包括协程与通道；下篇包括各种工具类的使用。</p>
        
          <p class="article-more-link">
            <a href="/2025/11/07/GoByExample(up)/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/07/GoByExample(up)/" data-id="cuida49bBYdvSWCD7V36XVU4s" data-title="Go语言基础学习（上）" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go%E5%AD%A6%E4%B9%A0/" rel="tag">Go学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-11-盛最多水的容器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/06/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2025-11-06T02:08:48.000Z" itemprop="datePublished">2025-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/">算法刷题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/06/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/">11. 盛最多水的容器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="问题与示例："><a href="#问题与示例：" class="headerlink" title="问题与示例："></a>问题与示例：</h4><p>给定一个长度为 <code>n</code> 的整数数组 <code>height</code> 。有 <code>n</code> 条垂线，第 <code>i</code> 条线的两个端点是 <code>(i, 0)</code> 和 <code>(i, height[i])</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。</p>
        
          <p class="article-more-link">
            <a href="/2025/11/06/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/06/11-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/" data-id="cuidHomeDJ3WV8mJNU_GDOQsO" data-title="11. 盛最多水的容器" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode-Top100/" rel="tag">LeetCode Top100</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-283-移动零" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/06/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/" class="article-date">
  <time class="dt-published" datetime="2025-11-06T00:39:01.000Z" itemprop="datePublished">2025-11-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/">算法刷题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/06/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/">283. 移动零</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="问题与示例："><a href="#问题与示例：" class="headerlink" title="问题与示例："></a>问题与示例：</h4><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p>
        
          <p class="article-more-link">
            <a href="/2025/11/06/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/06/283-%E7%A7%BB%E5%8A%A8%E9%9B%B6/" data-id="cuid8g_SKsu9oZbrg1eodUXEN" data-title="283. 移动零" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode-Top100/" rel="tag">LeetCode Top100</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-128-最长连续序列" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/11/05/128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" class="article-date">
  <time class="dt-published" datetime="2025-11-05T06:46:34.000Z" itemprop="datePublished">2025-11-05</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/">算法刷题</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/11/05/128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/">128. 最长连续序列</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h4 id="问题与示例："><a href="#问题与示例：" class="headerlink" title="问题与示例："></a>问题与示例：</h4><p>给定一个未排序的整数数组 <code>nums</code> ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p>
        
          <p class="article-more-link">
            <a href="/2025/11/05/128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://ziancoderman.github.io/2025/11/05/128-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/" data-id="cuidmm2pRmQfMy9cFAs2wdGp9" data-title="128. 最长连续序列" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode-Top100/" rel="tag">LeetCode Top100</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98/">算法刷题</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go-Interview-Practice/" rel="tag">Go Interview Practice</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go%E5%AD%A6%E4%B9%A0/" rel="tag">Go学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode-Top100/" rel="tag">LeetCode Top100</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" rel="tag">双指针</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%93%88%E5%B8%8C/" rel="tag">哈希</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" rel="tag">贪心算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Go-Interview-Practice/" style="font-size: 17.5px;">Go Interview Practice</a> <a href="/tags/Go%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">Go学习</a> <a href="/tags/LeetCode-Top100/" style="font-size: 20px;">LeetCode Top100</a> <a href="/tags/%E5%8F%8C%E6%8C%87%E9%92%88/" style="font-size: 12.5px;">双指针</a> <a href="/tags/%E5%93%88%E5%B8%8C/" style="font-size: 15px;">哈希</a> <a href="/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/" style="font-size: 10px;">贪心算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/11/">十一月 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/11/28/10-%E5%A4%9A%E6%80%81%E5%BD%A2%E7%8A%B6%E8%AE%A1%E7%AE%97%E5%99%A8/">#10.多态形状计算器</a>
          </li>
        
          <li>
            <a href="/2025/11/28/13-%E8%BF%9B%E8%A1%8C%20SQL%20%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/">#13.进行 SQL 数据库操作</a>
          </li>
        
          <li>
            <a href="/2025/11/26/4-%E5%B9%B6%E5%8F%91BFS%E6%9F%A5%E8%AF%A2/">#4.并发BFS查询</a>
          </li>
        
          <li>
            <a href="/2025/11/26/5-HTTP%E8%AE%A4%E8%AF%81%E4%B8%AD%E9%97%B4%E4%BB%B6/">#5.HTTP认证中间件</a>
          </li>
        
          <li>
            <a href="/2025/11/12/GoByExample(down)/">Go语言基础学习（下）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 zianCoderMan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>